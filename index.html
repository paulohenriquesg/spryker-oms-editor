<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=720, initial-scale=1.0">
    <title>OMS Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fast-xml-parser/4.0.12/fxparser.min.js"
            integrity="sha512-HGrrIN/LyGNpsITQqS0Oz+0rCFt/+2/eymCPchz/Pvx8JofaxmLfoEJNIix9R1iHEnScT+HSt8WBifDINQu89g=="
            crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/js/all.min.js"
            integrity="sha256-KzZiKy0DWYsnwMF+X1DvQngQ2/FxF7MF3Ff72XcpuPs=" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"
          integrity="sha256-h20CPZ0QyXlBuAw7A+KluUYx/3pK+c7lYEpqLTlxjYQ=" crossorigin="anonymous"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jerosoler/Drawflow/dist/drawflow.min.css">
    <script src="https://cdn.jsdelivr.net/gh/jerosoler/Drawflow/dist/drawflow.min.js"></script>

    <style>
        :root {
            --border-color: #cacaca;
            --background-color: #ffffff;

            --background-box-title: #f7f7f7;
        }

        html,
        body {
            margin: 0px;
            padding: 0px;
            width: 100vw;
            height: 100vh;
            /* overflow: hidden; */
            font-family: 'Roboto', sans-serif;
        }

        header {
            height: 66px;
            border-bottom: 1px solid var(--border-color);
            padding-left: 20px;
        }

        header h2 {
            margin: 0px;
            line-height: 66px;
        }

        header a {
            color: black;
        }

        .them-edit-link {
            position: absolute;
            top: 10px;
            right: 100px;
            color: black;
            font-size: 40px;
        }

        .them-edit-link a {
            text-decoration: none;
        }

        .github-link {
            position: absolute;
            top: 10px;
            right: 20px;
            color: black;
        }

        .wrapper {
            width: 100%;
            height: calc(100vh - 67px);
            display: flex;
        }

        .col {
            overflow: auto;
            width: 300px;
            height: 100%;
            border-right: 1px solid var(--border-color);
        }

        .drag-drawflow {
            line-height: 50px;
            border-bottom: 1px solid var(--border-color);
            padding-left: 20px;
            cursor: move;
            user-select: none;
        }

        .menu {
            position: absolute;
            height: 40px;
            display: block;
            background: white;
            width: 100%;
        }

        .menu ul {
            padding: 0px;
            margin: 0px;
            line-height: 40px;
        }

        .menu ul li {
            display: inline-block;
            margin-left: 10px;
            border-right: 1px solid var(--border-color);
            padding-right: 10px;
            line-height: 40px;
            cursor: pointer;
        }

        .menu ul li.selected {
            font-weight: bold;
        }

        .btn-export {
            float: right;
            position: absolute;
            top: 10px;
            right: 10px;
            color: white;
            font-weight: bold;
            border: 1px solid #0e5ba3;
            background: #4ea9ff;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            z-index: 5;
        }

        .btn-clear {
            float: right;
            position: absolute;
            top: 10px;
            right: 85px;
            color: white;
            font-weight: bold;
            border: 1px solid #96015b;
            background: #e3195a;
            padding: 5px 10px;
            border-radius: 4px;
            cursor: pointer;
            z-index: 5;
        }

        .swal-wide {
            width: 80% !important;
        }

        .btn-lock {
            float: right;
            position: absolute;
            bottom: 10px;
            right: 140px;
            display: flex;
            font-size: 24px;
            color: white;
            padding: 5px 10px;
            background: #555555;
            border-radius: 4px;
            border-right: 1px solid var(--border-color);
            z-index: 5;
            cursor: pointer;
        }

        .bar-zoom {
            float: right;
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            font-size: 24px;
            color: white;
            padding: 5px 10px;
            background: #555555;
            border-radius: 4px;
            border-right: 1px solid var(--border-color);
            z-index: 5;
        }

        .bar-zoom svg {
            cursor: pointer;
            padding-left: 10px;
        }

        .bar-zoom svg:nth-child(1) {
            padding-left: 0px;
        }

        #drawflow {
            position: relative;
            width: calc(100vw - 301px);
            height: calc(100% - 50px);
            top: 40px;
            background: var(--background-color);
            background-size: 25px 25px;
            background-image: linear-gradient(to right, #f1f1f1 1px, transparent 1px),
            linear-gradient(to bottom, #f1f1f1 1px, transparent 1px);
        }

        @media only screen and (max-width: 768px) {
            .col {
                width: 50px;
            }

            .col .drag-drawflow span {
                display: none;
            }

            #drawflow {
                width: calc(100vw - 51px);
            }
        }


        /* Editing Drawflow */

        .drawflow .drawflow-node {
            background: var(--background-color);
            border: 1px solid var(--border-color);
            -webkit-box-shadow: 0 2px 15px 2px var(--border-color);
            box-shadow: 0 2px 15px 2px var(--border-color);
            padding: 0px;
            width: 200px;
        }

        .drawflow .drawflow-node.selected {
            background: white;
            border: 1px solid #4ea9ff;
            -webkit-box-shadow: 0 2px 20px 2px #4ea9ff;
            box-shadow: 0 2px 20px 2px #4ea9ff;
        }

        .drawflow .drawflow-node.selected .title-box {
            color: #22598c;
            /*border-bottom: 1px solid #4ea9ff;*/
        }

        .drawflow .connection .main-path {
            stroke: #4ea9ff;
            stroke-width: 3px;
        }

        .drawflow .drawflow-node .input,
        .drawflow .drawflow-node .output {
            height: 15px;
            width: 15px;
            border: 2px solid var(--border-color);
        }

        .drawflow .drawflow-node .input:hover,
        .drawflow .drawflow-node .output:hover {
            background: #4ea9ff;
        }

        .drawflow .drawflow-node .output {
            right: 10px;
        }

        .drawflow .drawflow-node .input {
            left: -10px;
            background: white;
        }

        .drawflow > .drawflow-delete {
            border: 2px solid #43b993;
            background: white;
            color: #43b993;
            -webkit-box-shadow: 0 2px 20px 2px #43b993;
            box-shadow: 0 2px 20px 2px #43b993;
        }

        .drawflow-delete {
            border: 2px solid #4ea9ff;
            background: white;
            color: #4ea9ff;
            -webkit-box-shadow: 0 2px 20px 2px #4ea9ff;
            box-shadow: 0 2px 20px 2px #4ea9ff;
        }

        .drawflow-node .title-box {
            height: 50px;
            line-height: 50px;
            background: var(--background-box-title);
            border-bottom: 1px solid #e9e9e9;
            border-radius: 4px 4px 0px 0px;
            padding-left: 10px;
        }

        .drawflow .title-box svg {
            position: initial;
        }

        .drawflow-node .box {
            padding: 10px 20px 20px 20px;
            font-size: 14px;
            color: #555555;

        }

        .drawflow-node .box p {
            margin-top: 5px;
            margin-bottom: 5px;
        }

        .drawflow-node.welcome {
            width: 250px;
        }

        .drawflow-node.slack .title-box {
            border-radius: 4px;
        }

        .drawflow-node input,
        .drawflow-node select,
        .drawflow-node textarea {
            border-radius: 4px;
            border: 1px solid var(--border-color);
            height: 30px;
            line-height: 30px;
            font-size: 16px;
            width: 158px;
            color: #555555;
        }

        .drawflow-node textarea {
            height: 100px;
        }


        .drawflow-node.personalized {
            background: red;
            height: 200px;
            text-align: center;
            color: white;
        }

        .drawflow-node.personalized .input {
            background: yellow;
        }

        .drawflow-node.personalized .output {
            background: green;
        }

        .drawflow-node.personalized.selected {
            background: blue;
        }

        .drawflow .connection .point {
            stroke: var(--border-color);
            stroke-width: 2;
            fill: white;

        }

        .drawflow .connection .point.selected,
        .drawflow .connection .point:hover {
            fill: #4ea9ff;
        }


        /* Modal */
        .modal {
            display: none;
            position: fixed;
            z-index: 7;
            left: 0;
            top: 0;
            width: 100vw;
            height: 100vh;
            overflow: auto;
            background-color: rgb(0, 0, 0);
            background-color: rgba(0, 0, 0, 0.7);

        }

        .modal-content {
            position: relative;
            background-color: #fefefe;
            margin: 15% auto;
            /* 15% from the top and centered */
            padding: 20px;
            border: 1px solid #888;
            width: 400px;
            /* Could be more or less, depending on screen size */
        }

        /* The Close Button */
        .modal .close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
        }

        @media only screen and (max-width: 768px) {
            .modal-content {
                width: 80%;
            }
        }

        .happy {
            background-color: #ebf2eb;
        }

        .event {
            background-color: #ecf0f5;
        }

        .transition {
            background-color: #FFF4BD;
        }


        /* Vertical connectors */
        .drawflow .drawflow-node {
            display: block;
        }

        .drawflow .drawflow-node .inputs,
        .drawflow .drawflow-node .outputs {
            display: flex;
            width: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 0;
        }

        .drawflow .drawflow-node .input {
            top: 0px;
            left: 0px;
        }

        .drawflow .drawflow-node .output {
            top: 0px;
            right: 0px;
        }

        /* handlding SVG */
        .drawflow-node.shape {
            background: transparent;
            border: 0px;
            pointer-events: none;
        }

        .drawflow-node.shape.selected {
            background: transparent;
        }

        .drawflow-node.shape polygon {
            pointer-events: all;
        }

        .drawflow-node.shape .input,
        .drawflow-node.shape .output {
            pointer-events: all;
        }

        .drawflow-node.shape .inputs .input_1 {
            top: 187px;
            left: -10px;
        }

        .drawflow-node.shape .outputs .output_1 {
            top: 7px;
            left: 13px;
        }
    </style>
</head>

<body>
<h1>OMS Converter</h1>
<input onchange='upload(event)' type='file' multiple/>
<button onclick="process()">Process</button>
<br>
<div id="textareas"></div>

<hr>
OMS Process name: <input type="text" name="processName">
<button onclick="exportGraph()">Export</button>
<br>
<textarea name="xml" id="export" cols="100" rows="20"></textarea>
<textarea name="xml" id="exportXml" cols="100" rows="20"></textarea>
<hr>


<div class="wrapper">
    <div class="col">
        <div class="drag-drawflow" draggable="true" ondragstart="drag(event)" data-node="state">
            <i class="fa fa-cogs"></i><span> State</span>
        </div>
        <div class="drag-drawflow" draggable="true" ondragstart="drag(event)" data-node="condition">
            <i class="fa fa-question-circle"></i><span> Condition</span>
        </div>
        <div class="drag-drawflow" draggable="true" ondragstart="drag(event)" data-node="transition">
            <i class="fa fa-exchange-alt"></i><span> Transition</span>
        </div>
        <div class="drag-drawflow" draggable="true" ondragstart="drag(event)" data-node="event">
            <i class="fa fa-bolt"></i><span> Event</span>
        </div>
    </div>
    <div class="col-right">
        <div id="drawflow" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
        <!--  style="width: 5000px;height: 5000px;" -->
    </div>
</div>


<script>
    let id = document.getElementById("drawflow");
    const editor = new Drawflow(id);

    // editor.reroute = true;
    editor.editor_mode = 'edit'; // Default
    editor.start();

    let mapNodeStateElement = [];
    let mapNodeEventElement = [];
    let mapNodeTransitionElement = [];
    let mapNodeConditionElement = [];
    let mapNodePositions = [];
    let mapNodeConnectedThruConditions = [];

    let combinedEventsData = [];
    let combinedStatesData = [];
    let combinedTransitionsData = [];
    let combinedConditionsData = [];

    let alreadyPositioned = [];
    let mapNodeDependencies = [];

    function changeOption(e) {
        const id = e.target.closest(".drawflow-node").id.slice(5);
        const value = e.target.value;
        const node = editor.getNodeFromId(id);
        const data = node.data;
        data['reserved'] = value;
        editor.updateNodeDataFromId(id, data);
    }

    let htmlState = `<div>
            <div class="title-box"><i class="fa fa-cogs"></i> State</div>
            <div class="box happy" >
                <p>Name</p>
                <input type="text" df-name>
                <p>Reserved</p>
                <select name="df-reserved" onchange="changeOption(event)">
                    <option value="">Select</option>
                    <option value="true">true</option>
                    <option value="false">false</option>
                </select>
                <p>Flag</p>
                <input type="text" df-flag>
                <p>Display</p>
                <input type="text" df-display>
            </div>
          </div>`;

    //   var htmlState = `<div class="shape"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="#fff" fill-rule="evenodd" stroke="#000" stroke-linecap="round" stroke-linejoin="round"><path d="M54.5 24.5h-45C5.345 24.5 2 27.845 2 32s3.345 7.5 7.5 7.5h45c4.155 0 7.5-3.345 7.5-7.5s-3.345-7.5-7.5-7.5z" stroke="#838383" fill="#efc"/><input type="text" df-name></svg></div>`;
    //   var htmlState = `<div class="shape"><svg xmlns="http://www.w3.org/2000/svg" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:xlink="http://www.w3.org/1999/xlink" id="svg548" inkscape:version="0.38.1" sodipodi:docbase="/var/www/html/svg_gallery/svg/flowcharts" sodipodi:docname="fc15.svg" sodipodi:version="0.32" viewBox="15.12 72.22 469.66 361.17">  <metadata>    <rdf:RDF xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">      <cc:Work rdf:about="">        <dc:title>Clipart by Nicu Buculei - fc23</dc:title>        <dc:description></dc:description>        <dc:subject>          <rdf:Bag>            <rdf:li>flowchart</rdf:li>            <rdf:li></rdf:li>            <rdf:li>shape</rdf:li>          </rdf:Bag>        </dc:subject>        <dc:publisher>          <cc:Agent rdf:about="http://www.openclipart.org">            <dc:title>Nicu Buculei</dc:title>          </cc:Agent>        </dc:publisher>        <dc:creator>          <cc:Agent>            <dc:title>Nicu Buculei</dc:title>          </cc:Agent>        </dc:creator>        <dc:rights>          <cc:Agent>            <dc:title>Nicu Buculei</dc:title>          </cc:Agent>        </dc:rights>        <dc:date></dc:date>        <dc:format>image/svg+xml</dc:format>        <dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"></dc:type>        <cc:license rdf:resource="http://web.resource.org/cc/PublicDomain"></cc:license>        <dc:language>en</dc:language>      </cc:Work>      <cc:License rdf:about="http://web.resource.org/cc/PublicDomain">        <cc:permits rdf:resource="http://web.resource.org/cc/Reproduction"></cc:permits>        <cc:permits rdf:resource="http://web.resource.org/cc/Distribution"></cc:permits>        <cc:permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"></cc:permits>      </cc:License>    </rdf:RDF>  </metadata>  <defs id="defs550"></defs>  <sodipodi:namedview id="base" inkscape:cx="197.75166" inkscape:cy="200.00000" inkscape:window-height="500" inkscape:window-width="400" inkscape:window-x="5" inkscape:window-y="46" inkscape:zoom="0.77250000" showgrid="true"></sodipodi:namedview>  <g id="g827">    <path d="M 67.369808,93.462270 L 449.01471,95.410270 C 449.01471,95.410270 486.60595,152.87637 484.70250,255.14737 C 484.76992,368.13237 450.91816,431.44237 450.91816,431.44237 L 68.321534,433.39037 C 68.321534,433.39037 31.203905,370.08037 35.010811,255.14737 C 34.059085,146.05937 66.418081,94.436270 67.369808,93.462270 z " id="path1546" sodipodi:nodetypes="ccccccc" style="fill:#000000;fill-rule:evenodd;stroke:none;stroke-opacity:1;stroke-width:3.75;stroke-linejoin:miter;stroke-linecap:butt;fill-opacity:0.25;stroke-dasharray:none;"></path>    <path d="M 51.6224 56.8269 L 442.199 58.7749 C 442.199 58.7749 480.67 116.241 478.722 218.512 C 478.791 331.497 444.147 394.807 444.147 394.807 L 52.5964 396.755 C 52.5964 396.755 14.6101 333.445 18.5061 218.512 C 17.5321 109.424 50.6484 57.8009 51.6224 56.8269 z " id="path605" sodipodi:nodetypes="ccccccc" style="fill:#ffffff;fill-rule:evenodd;stroke:black;stroke-opacity:1;stroke-width:10.116339;stroke-linejoin:round;stroke-linecap:butt;fill-opacity:1;stroke-dasharray:none;" transform="matrix(0.977132,0.000000,0.000000,1.000000,2.364802,20.45414)"></path>    <text x="0" y="50" font-family="Verdana" font-size="35" fill="blue">Hello</text></g></svg></div>`;
    //   var htmlState = `<div class="shape"><svg xmlns="http://www.w3.org/2000/svg" fill="#fff" fill-rule="evenodd" stroke="#000" stroke-linecap="round" stroke-linejoin="round" viewBox="1.5 24 61 16"><path d="M54.5 24.5h-45C5.345 24.5 2 27.845 2 32s3.345 7.5 7.5 7.5h45c4.155 0 7.5-3.345 7.5-7.5s-3.345-7.5-7.5-7.5z" stroke="#838383" fill="#efc"></path></svg></div>`;

    let htmlTransition = `<div>
            <div class="title-box"><i class="fa fa-exchange-alt"></i> Transition</div>
            <div class="box transition" >
                <p>Event</p>
                <input type="text" df-event>
                <p>Source</p>
                <input type="text" df-source>
                <p>Target</p>
                <input type="text" df-target>
                <p>Condition</p>
                <input type="text" df-condition>
                <p>Happy</p>
                <input type="text" df-happy>
            </div>
          </div>`;

    let htmlCondition = `
        <div>
          <div class="title-box"><i class="fa fa-question-circle"></i> condition</div>
        </div>
        `;
    let htmlEvent = `<div>
            <div class="title-box"><i class="fa fa-bolt"></i> Event</div>
            <div class="box event" >
                <p>Name</p>
                <input type="text" df-name>
                <p>Command</p>
                <input type="text" df-command>
                <p>onEnter</p>
                <input type="text" df-onEnter>
                <p>Timeout</p>
                <input type="text" df-timeout>
                <p>Timeout Processor</p>
                <input type="text" df-timeoutProcessor>
                <p>Manual</p>
                <input type="text" df-manual>
            </div>
          </div>`;

    editor.on('nodeCreated', function (id) {
        // console.log("Node created " + id);
        let nodeData = editor.getNodeFromId(id);

        if (nodeData.name === 'state') {
            // console.log("Node state created " + id);
            if (combinedStatesData[nodeData.data.name] === undefined) {
                combinedStatesData[nodeData.data.name] = [];
            }

            combinedStatesData[nodeData.data.name]['nodeId'] = id;
            combinedStatesData[nodeData.data.name]['posX'] = nodeData.pos_x;
            combinedStatesData[nodeData.data.name]['posY'] = nodeData.pos_y;


            mapNodeStateElement[nodeData.data.name] = id;
        }
        if (nodeData.name === 'event') {
            // console.log("Node event created " + id);
            if (combinedEventsData[nodeData.data.name] === undefined) {
                combinedEventsData[nodeData.data.name] = [];
            }

            combinedEventsData[nodeData.data.name]['nodeId'] = id;
            combinedEventsData[nodeData.data.name]['posX'] = nodeData.pos_x;
            combinedEventsData[nodeData.data.name]['posY'] = nodeData.pos_y;
            combinedEventsData[nodeData.data.name] = id;

            mapNodeEventElement[nodeData.data.name] = id;

            // events have no output
            editor.removeNodeOutput(id, 'output_1');
        }

        if (nodeData.name === 'transition') {
            // console.log("Node transition created " + id);
            if (combinedTransitionsData[nodeData.data.name] === undefined) {
                combinedTransitionsData[nodeData.data.name] = [];
            }

            combinedTransitionsData[nodeData.data.name]['nodeId'] = id;
            combinedTransitionsData[nodeData.data.name]['posX'] = nodeData.pos_x;
            combinedTransitionsData[nodeData.data.name]['posY'] = nodeData.pos_y;
            mapNodeTransitionElement[nodeData.data.name] = id;
        }

        if (nodeData.name === 'condition') {
            // console.log("Node condition created " + id);
            mapNodeConditionElement[nodeData.data.name] = id;
        }
    })


    function process() {
        const options = {
            ignoreAttributes: false,
            parseAttributeValue: true,
            allowBooleanAttributes: true
        };

        const parser = new XMLParser(options);

        let combinedEvents = [];
        let combinedStates = [];
        let combinedTransitions = [];

        let xmls = document.getElementsByClassName('xml');
        for (let index = 0; index < xmls.length; index++) {
            const element = xmls[index].value;
            const parsedElement = parser.parse(element);

            let process = parsedElement.statemachine.process;

            // handles main process
            if (parsedElement.statemachine.process.length !== undefined) {
                process = parsedElement.statemachine.process[0];
                document.getElementsByName('processName')[0].value = process['@_name'];
            }

            combinedEvents = combinedEvents.concat(process.events.event);
            combinedStates = combinedStates.concat(process.states.state);
            combinedTransitions = combinedTransitions.concat(process.transitions.transition);
        }

        for (let index = 0; index < combinedStates.length; index++) {
            const element = combinedStates[index];
            // editor.addNode('state', 1, 1, (50 + 250*index), (20 + (270 * index)), '', data, html);
            // editor.addNode('state', 1, 1, (50 + 250 * index), (20), '', data, htmlState);
            combinedStatesData[element['@_name']] = {
                "name": element['@_name'],
                "color": (element['@_reserved'] !== undefined && element['@_reserved'] === true) ? '#ebf2eb' : '#ffffff',
                "flag": (element['flag'] !== undefined) ? element['flag'] : '',
                "reserved": (element['@_reserved'] !== undefined) ? element['@_reserved'] : 'false',
                "display": (element['@_display'] !== undefined) ? element['@_display'] : '',
                "nodeId": '',
                "childrenCount": 0,
                "childrenNames": [],
                "statesCount": 0,
                "stateNames": [],
            };
        }

        for (let index = 0; index < combinedEvents.length; index++) {
            const element = combinedEvents[index];
            // editor.addNode('state', 1, 1, (50 + 250*index), (20 + (270 * index)), '', data, html);
            // editor.addNode('event', 1, 1, (50 + 250 * index), (800), '', data, htmlEvent);
            combinedEventsData[element['@_name']] = {
                "name": element['@_name'],
                "timeout": (element['@_timeout'] !== undefined) ? element['@_timeout'] : '',
                "onEnter": (element['@_onEnter'] !== undefined) ? element['@_onEnter'] : '',
                "command": (element['@_command'] !== undefined) ? element['@_command'] : '',
                "manual": (element['@_manual'] !== undefined) ? element['@_manual'] : '',
                "timeoutProcessor": (element['@_timeoutProcessor'] !== undefined) ? element['@_timeoutProcessor'] : '',
                "nodeId": '',
                "childrenCount": 0,
                "childrenNames": [],
            };
        }

        let posX = 1000;
        let posY = 1000;
        for (let index = 0; index < combinedTransitions.length; index++) {
            const element = combinedTransitions[index];
            let data = {
                "name": (element['event'] + '-' + element['source'] + '-' + element['target']).replaceAll(' ', '-'),
                "event": element['event'],
                "source": (element['source'] !== undefined) ? element['source'] : '',
                "target": (element['target'] !== undefined) ? element['target'] : '',
                "condition": (element['@_condition'] !== undefined) ? element['@_condition'] : '',
                "happy": (element['@_happy'] !== undefined) ? element['@_happy'] : false,
                "nodeId": '',
            };
            // editor.addNode('state', 1, 1, (50 + 250*index), (20 + (270 * index)), '', data, html);
            // editor.addNode('transition', 1, 1, (50 + 250 * index), (350), '', data, htmlTransition);

            // handle missing parts of the available OMS
            if (combinedStatesData[element['source']] === undefined) {
                console.log(element['source'] + ' not found');
                continue;
            }
            if (combinedStatesData[element['target']] === undefined) {
                console.log(element['target'] + ' not found');
                continue;
            }


            if (combinedStatesData[element['source']]['nodeId'] === '') {
                // editor.addNode('state', 1, 1, posX, posY, '', combinedStatesData[element['source']], htmlState);
            }

            if (combinedStatesData[element['target']]['nodeId'] === '') {
                combinedStatesData[element['source']]['childrenCount'] += 1;
                combinedStatesData[element['source']]['childrenNames'].push(element['target']);
                combinedStatesData[element['source']]['statesCount'] += 1;
                combinedStatesData[element['source']]['stateNames'].push(element['target']);

                if (combinedEventsData[element['event']] !== undefined) {
                    combinedEventsData[element['event']]['childrenCount'] += 1;
                    combinedEventsData[element['event']]['childrenNames'].push(element['target']);
                } else {
                    console.log('Event ' + element['event'] + ' not found')
                }

                // posY = combinedStatesData[element['source']]['posY'] + 500;
                // posX = combinedStatesData[element['source']]['posX'];
                if (mapNodePositions[posX] !== undefined) {
                    if (mapNodePositions[posX][posY] !== undefined) {
                        // posX += 400;
                    }
                }

                if (combinedStatesData[element['source']]['childrenCount'] > 1) {
                    //posX += (400 * (combinedStatesData[element['source']]['childrenCount'] - 1));
                }

                let event = element['event'].replaceAll(' ', '-');
                // console.log(element['source'], event, combinedStatesData[element['source']]['stateNames'][event])
                if (combinedStatesData[element['source']]['stateNames'][event] === undefined) {
                    combinedStatesData[element['source']]['stateNames'][event] = [];
                }
                combinedStatesData[element['source']]['stateNames'][event].push(element['target']);
                // console.log(element['source'], event, combinedStatesData[element['source']]['stateNames'][event])


                // editor.addNode('state', 1, 1, posX, posY, '', combinedStatesData[element['target']], htmlState);
            }

            // editor.addConnection(combinedStatesData[element['source']]['nodeId'], combinedStatesData[element['target']]['nodeId'], 'output_1', 'input_1');

            combinedTransitionsData[data['name']] = data;
        }
        // console.log(combinedStatesData);
        // console.log(combinedTransitionsData);
        // console.log(combinedEventsData);

        // add states to canvas
        for (let [key, state] of Object.entries(combinedStatesData)) {
            editor.addNode('state', 1, 1, 10, 10, '', state, htmlState);
        }

        // add transitions to canvas
        for (let [key, transition] of Object.entries(combinedTransitionsData)) {
            editor.addNode('transition', 1, 1, 100, 100, '', transition, htmlTransition);
        }

        for (const [stateName, state] of Object.entries(combinedStatesData)) {
            for (const [conditionName, relatedStateNames] of Object.entries(state.stateNames)) {
                if (relatedStateNames.length === 2) {
                    // add condition graph
                    editor.addNode('condition', 1, 1, 100, 100, '', {name: conditionName}, htmlCondition);

                    // add connection between source and condition
                    editor.addConnection(mapNodeStateElement[stateName], mapNodeConditionElement[conditionName], 'output_1', 'input_1');
                    for (const [key2, relatedStateName] of Object.entries(relatedStateNames)) {
                        // add connection between condition and target
                        let transitionKey = (conditionName + '-' + stateName + '-' + relatedStateName).replaceAll(' ', '-');
                        console.log(combinedTransitionsData[transitionKey])

                        editor.addConnection(mapNodeConditionElement[conditionName], mapNodeTransitionElement[transitionKey], 'output_1', 'input_1');
                        editor.addConnection(mapNodeTransitionElement[transitionKey], mapNodeStateElement[relatedStateName], 'output_1', 'input_1');

                        if (combinedTransitionsData[transitionKey]['happy'] === true) {
                            let label = document.querySelector(".connection.node_in_node-" + mapNodeTransitionElement[transitionKey] + ".node_out_node-" + mapNodeConditionElement[conditionName] + ".output_1.input_1");

                            addLabelText(label, "happy");
                        }

                        if (mapNodeConnectedThruConditions[stateName] === undefined) {
                            mapNodeConnectedThruConditions[stateName] = [];
                            mapNodeConnectedThruConditions[stateName]['transitionKey'] = [];
                            mapNodeConnectedThruConditions[stateName]['conditionName'] = '';
                            mapNodeConnectedThruConditions[stateName]['states'] = [];
                        }
                        mapNodeConnectedThruConditions[stateName]['transitionKey'].push(transitionKey);
                        mapNodeConnectedThruConditions[stateName]['conditionName'] = conditionName;
                        mapNodeConnectedThruConditions[stateName]['states'][relatedStateName] = true;
                    }
                }
            }
        }

        let newCombinedStateData = [];
        if (combinedStatesData['new'] !== undefined) {
            newCombinedStateData['new'] = combinedStatesData['new']
        }

        for (const [stateName, state] of Object.entries(combinedStatesData)) {
            if (stateName === 'new') {
                continue;
            }

            newCombinedStateData[stateName] = combinedStatesData[stateName]
        }
        combinedStatesData = newCombinedStateData;

        let counter = 0;
        for (const [stateNameKey, state] of Object.entries(combinedStatesData)) {
            let stateElement = mapNodeStateElement[stateNameKey];

            if (stateNameKey === 'new') {
                editor.drawflow.drawflow.Home.data[stateElement].pos_x = 10;
                editor.drawflow.drawflow.Home.data[stateElement].pos_y = 10;
                document.getElementById("node-" + stateElement).style.top = 10 + "px";
                document.getElementById("node-" + stateElement).style.left = "10px";
                editor.updateConnectionNodes("node-" + stateElement);
            } else {
                if (alreadyPositioned.indexOf(stateNameKey) === -1) {
                    editor.drawflow.drawflow.Home.data[stateElement].pos_x = 10;
                    editor.drawflow.drawflow.Home.data[stateElement].pos_y = (10 + (500 * counter));
                    document.getElementById("node-" + stateElement).style.top = "10px";
                    document.getElementById("node-" + stateElement).style.left = (10 + (500 * counter)) + "px";
                    editor.updateConnectionNodes("node-" + stateElement);
                }
            }

            for (const [conditionName, stateName] of Object.entries(state.stateNames)) {
                if (stateName.length === 2) {
                    let conditionElement = mapNodeConditionElement[conditionName];

                    editor.drawflow.drawflow.Home.data[conditionElement].pos_x = editor.drawflow.drawflow.Home.data[stateElement].pos_x + 800;
                    editor.drawflow.drawflow.Home.data[conditionElement].pos_y = editor.drawflow.drawflow.Home.data[stateElement].pos_y + 400;
                    document.getElementById("node-" + conditionElement).style.top = (editor.drawflow.drawflow.Home.data[stateElement].pos_y + 400) + "px";
                    document.getElementById("node-" + conditionElement).style.left = (editor.drawflow.drawflow.Home.data[stateElement].pos_x + 800) + "px";
                    editor.updateConnectionNodes("node-" + conditionElement);

                    let leftTransitionKey = (conditionName + '-' + stateNameKey + '-' + stateName[0]).replaceAll(' ', '-');
                    console.log(leftTransitionKey)
                    let leftTransitionElement = mapNodeTransitionElement[leftTransitionKey];
                    editor.drawflow.drawflow.Home.data[leftTransitionElement].pos_x = editor.drawflow.drawflow.Home.data[conditionElement].pos_x + 250;
                    editor.drawflow.drawflow.Home.data[leftTransitionElement].pos_y = editor.drawflow.drawflow.Home.data[conditionElement].pos_y + 300;
                    document.getElementById("node-" + leftTransitionElement).style.top = (editor.drawflow.drawflow.Home.data[conditionElement].pos_y + 300) + "px";
                    document.getElementById("node-" + leftTransitionElement).style.left = (editor.drawflow.drawflow.Home.data[conditionElement].pos_x + 250) + "px";
                    editor.updateConnectionNodes("node-" + leftTransitionElement);
                    alreadyPositioned.push(leftTransitionKey);

                    let leftOption = mapNodeStateElement[stateName[0]];
                    editor.drawflow.drawflow.Home.data[leftOption].pos_x = editor.drawflow.drawflow.Home.data[leftTransitionElement].pos_x;
                    editor.drawflow.drawflow.Home.data[leftOption].pos_y = editor.drawflow.drawflow.Home.data[leftTransitionElement].pos_y + 500;
                    document.getElementById("node-" + leftOption).style.top = (editor.drawflow.drawflow.Home.data[leftTransitionElement].pos_y + 500) + "px";
                    document.getElementById("node-" + leftOption).style.left = (editor.drawflow.drawflow.Home.data[leftTransitionElement].pos_x) + "px";
                    editor.updateConnectionNodes("node-" + leftOption);
                    alreadyPositioned.push(stateName[0]);

                    let rightTransitionKey = (conditionName + '-' + stateNameKey + '-' + stateName[1]).replaceAll(' ', '-');
                    let rightTransitionElement = mapNodeTransitionElement[rightTransitionKey];
                    editor.drawflow.drawflow.Home.data[rightTransitionElement].pos_x = editor.drawflow.drawflow.Home.data[conditionElement].pos_x - 250;
                    editor.drawflow.drawflow.Home.data[rightTransitionElement].pos_y = editor.drawflow.drawflow.Home.data[conditionElement].pos_y + 300;
                    document.getElementById("node-" + rightTransitionElement).style.top = (editor.drawflow.drawflow.Home.data[conditionElement].pos_y + 300) + "px";
                    document.getElementById("node-" + rightTransitionElement).style.left = (editor.drawflow.drawflow.Home.data[conditionElement].pos_x - 250) + "px";
                    editor.updateConnectionNodes("node-" + rightTransitionElement);
                    alreadyPositioned.push(rightTransitionKey);

                    let rightOption = mapNodeStateElement[stateName[1]];
                    editor.drawflow.drawflow.Home.data[rightOption].pos_x = editor.drawflow.drawflow.Home.data[rightTransitionElement].pos_x;
                    editor.drawflow.drawflow.Home.data[rightOption].pos_y = editor.drawflow.drawflow.Home.data[rightTransitionElement].pos_y + 500;
                    document.getElementById("node-" + rightOption).style.top = (editor.drawflow.drawflow.Home.data[rightTransitionElement].pos_y + 500) + "px";
                    document.getElementById("node-" + rightOption).style.left = (editor.drawflow.drawflow.Home.data[rightTransitionElement].pos_x) + "px";
                    editor.updateConnectionNodes("node-" + rightOption);
                    alreadyPositioned.push(stateName[1]);
                }
            }

            counter++;
        }

        for (let [transitionKey, transition] of Object.entries(combinedTransitionsData)) {
            let sourceElement = mapNodeStateElement[transition['source']];
            let targetElement = mapNodeStateElement[transition['target']];
            let transitionElement = mapNodeTransitionElement[transitionKey];

            // link source to target state - if they are not linked by condition
            if (mapNodeConnectedThruConditions[transition['source']] === undefined) {
                console.log('transition linking source', transition['source'], 'placed');
                console.log('happy', transition['happy'])
                editor.addConnection(sourceElement, transitionElement, 'output_1', 'input_1');
                editor.addConnection(transitionElement, targetElement, 'output_1', 'input_1');
            } else {
                if (mapNodeConnectedThruConditions[transition['source']]['states'][transition['target']] === undefined) {
                    console.log('transition linking target', transition['target'], 'placed');
                    editor.addConnection(sourceElement, transitionElement, 'output_1', 'input_1');
                    editor.addConnection(transitionElement, targetElement, 'output_1', 'input_1');
                } else {
                    if (mapNodeConnectedThruConditions[transition['source']]['transitionKey'].indexOf(transitionKey) === -1) {
                        console.log('transition linking target', transition['target'], 'placed', sourceElement, transitionElement);
                        editor.addConnection(sourceElement, transitionElement, 'output_1', 'input_1');
                        editor.addConnection(transitionElement, targetElement, 'output_1', 'input_1');
                    }
                }
            }
            if (alreadyPositioned.indexOf(transitionKey) === -1) {
                editor.drawflow.drawflow.Home.data[transitionElement].pos_x = editor.drawflow.drawflow.Home.data[sourceElement].pos_x;
                editor.drawflow.drawflow.Home.data[transitionElement].pos_y = editor.drawflow.drawflow.Home.data[sourceElement].pos_y + 500;
                document.getElementById("node-" + transitionElement).style.top = (editor.drawflow.drawflow.Home.data[sourceElement].pos_y + 500) + "px";
                document.getElementById("node-" + transitionElement).style.left = (editor.drawflow.drawflow.Home.data[sourceElement].pos_x) + "px";
                editor.updateConnectionNodes("node-" + transitionElement);

                editor.drawflow.drawflow.Home.data[targetElement].pos_x = editor.drawflow.drawflow.Home.data[transitionElement].pos_x;
                editor.drawflow.drawflow.Home.data[targetElement].pos_y = editor.drawflow.drawflow.Home.data[transitionElement].pos_y + 500;
                document.getElementById("node-" + targetElement).style.top = (editor.drawflow.drawflow.Home.data[transitionElement].pos_y + 500) + "px";
                document.getElementById("node-" + targetElement).style.left = (editor.drawflow.drawflow.Home.data[transitionElement].pos_x) + "px";
                editor.updateConnectionNodes("node-" + targetElement);
            }
        }

        // repositioning nodes that overlap
        do {
            mapNodePositions = [];
            for (let [nodeKey, node] of Object.entries(document.querySelectorAll(".drawflow-node "))) {
                if (mapNodePositions[node.style.left + '_' + node.style.top] === undefined) {
                    mapNodePositions[node.style.left + '_' + node.style.top] = [];
                }
                mapNodePositions[node.style.left + '_' + node.style.top].push(node.id);
            }

            let filteredNodes = Object.values(mapNodePositions).filter(ob => ob.length > 1)
            for (let i = 0; i < filteredNodes.length; i++) {
                for (let j = 1; j < filteredNodes[i].length; j++) {
                    let node = filteredNodes[i][j];
                    let nodeElement = node.split('-')[1];
                    editor.drawflow.drawflow.Home.data[nodeElement].pos_x = editor.drawflow.drawflow.Home.data[nodeElement].pos_x + 250;
                    document.getElementById(node).style.left = (editor.drawflow.drawflow.Home.data[nodeElement].pos_x + 250) + "px";
                    editor.updateConnectionNodes(node);
                }
            }
        } while (Object.values(mapNodePositions).filter(ob => ob.length > 1).length > 0);

        let rightmostNode = 0;
        for (let [nodeKey, node] of Object.entries(document.querySelectorAll(".drawflow-node "))) {
            let leftPosition = +node.style.left.replaceAll('px', '');
            if (leftPosition > rightmostNode) {
                rightmostNode = leftPosition;
            }
        }

        // add events to canvas
        let eventCounter = 0;
        for (let [key, event] of Object.entries(combinedEventsData)) {
            editor.addNode('event', 1, 1, (rightmostNode + 300), (10 + (500 * eventCounter)), '', event, htmlEvent);
            eventCounter++;
        }

        // linking transitions and events
        for (let [transitionKey, transition] of Object.entries(combinedTransitionsData)) {
            console.log(transition)
            let transitionElement = mapNodeTransitionElement[transitionKey];
            let eventElement = combinedEventsData[transition.event];
            editor.addConnection(transitionElement, eventElement, 'output_1', 'input_1');
        }

        // let label1 = document.querySelector(".connection.node_in_node-2.node_out_node-1.output_1.input_1");

        // addLabelText(label1, "Something");

        function addLabelText(bgPath, labelText) {
            const newid = [bgPath.classList].join().replace(/\s/g, '');
            bgPath.childNodes[0].id = newid;
            let textElem = document.createElementNS(bgPath.namespaceURI, "text");
            let textElemPath = document.createElementNS(bgPath.namespaceURI, "textPath");
            textElemPath.setAttribute("href", `#${newid}`);
            textElemPath.setAttribute("text-anchor", "middle");
            textElemPath.setAttribute("startOffset", "50%");
            textElemPath.classList.add("label-text");
            textElemPath.textContent = labelText;
            textElem.appendChild(textElemPath);
            bgPath.appendChild(textElem);
        }


        // // console.log(mapNodeStateElement);
        // // console.log(mapNodeEventElement);
    }

    function exportGraph() {
        var exportdata = editor.export();

        let data = exportdata.drawflow.Home.data;
        for (const [key, value] of Object.entries(data)) {
            // // console.log(`${key}`, value);
        }

        document.getElementById('export').value = JSON.stringify(exportdata, null, 4);

        // let baseXml = '<?xml version="1.0"?><statemachine xmlns="spryker:oms-01" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="spryker:oms-01 http://static.spryker.com/oms-01.xsd"></statemachine';
        // let xml = new DOMParser().parseFromString(baseXml, "application/xml");

        let xml = document.implementation.createDocument("", "", null);
        let header = xml.createElementNS("spryker:oms-01", "statemachine");
        header.setAttribute('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance');
        header.setAttribute('xsi:schemaLocation', 'spryker:oms-01 http://static.spryker.com/oms-01.xsd');


        let process = xml.createElement("process");
        process.setAttribute('name', document.getElementsByName('processName')[0].value);
        process.setAttribute('main', 'true');

        let states = xml.createElement("states");
        let transitions = xml.createElement("transitions");
        let events = xml.createElement("events");

        let combinedEvents = [];
        let combinedStates = [];
        let combinedTransitions = [];

        for (const [key, value] of Object.entries(data)) {
            if (value.name === 'state') {
                combinedStates.push(value);

                let newState = xml.createElement("state");
                newState.setAttribute('name', value.data.name ?? '');
                newState.setAttribute('display', value.data.display ?? '');

                if (value.data.reserved === 'true') {
                    newState.setAttribute('reserved', true);
                }

                if (value.data.flag !== undefined && value.data.flag !== "") {
                    let flag = xml.createElement('flag');
                    let flagText = xml.createTextNode(value.data.flag);

                    flag.appendChild(flagText);
                    newState.appendChild(flag);
                }


                states.appendChild(newState);
            }
            if (value.name === 'transition') {
                combinedTransitions.push(value);

                let newTransition = xml.createElement("transition");

                if (value.data.happy === true) {
                    newTransition.setAttribute('happy', true);
                }

                if (value.data.condition !== undefined && value.data.condition !== "") {
                    newTransition.setAttribute('condition', value.data.condition);
                }

                let source = xml.createElement('source')
                let sourceText = xml.createTextNode(value.data.source ?? '');
                source.appendChild(sourceText);
                newTransition.appendChild(source);

                let target = xml.createElement('target')
                let targetText = xml.createTextNode(value.data.target ?? '');
                target.appendChild(targetText);
                newTransition.appendChild(target);

                let event = xml.createElement('event')
                let eventText = xml.createTextNode(value.data.event ?? '');
                event.appendChild(eventText);
                newTransition.appendChild(event);

                transitions.appendChild(newTransition);
            }
            if (value.name === 'event') {
                combinedEvents.push(value);

                let newEvent = xml.createElement("event");
                newEvent.setAttribute('name', value.data.name ?? '');

                if (value.data.manual === true) {
                    newEvent.setAttribute('manual', true);
                }

                if (value.data.command !== undefined && value.data.command !== "") {
                    newEvent.setAttribute('command', value.data.command);
                }

                if (value.data.timeout !== undefined && value.data.timeout !== "") {
                    newEvent.setAttribute('timeout', value.data.timeout);
                }

                if (value.data.timeoutProcessor !== undefined && value.data.timeoutProcessor !== "") {
                    newEvent.setAttribute('timeoutProcessor', value.data.timeoutProcessor);
                }

                if (value.data.onEnter === true) {
                    newEvent.setAttribute('onEnter', true);
                }

                events.appendChild(newEvent);
            }
        }

        process.appendChild(states);
        process.appendChild(transitions);
        process.appendChild(events);

        xml.appendChild(header)
        xml.documentElement.appendChild(process);

        document.getElementById('exportXml').value = new XMLSerializer().serializeToString(xml);
    }


    // EVENTS
    // Events!
    editor.on('nodeCreated', function (id) {
        console.log("Node created " + id);

        const node = editor.getNodeFromId(id);
        if (node.name === 'state') {
            const check = node.html.includes('select');
            if (check) {
                const reservedOptions = document.querySelectorAll(`#node-${id} select[name="df-reserved"] option`);
                reservedOptions.forEach(e => {
                    if (e.value === node.data.reserved) {
                        e.selected = true;
                    }
                });
            }
        }
    })

    editor.on('nodeRemoved', function (id) {
        console.log("Node removed " + id);
    })

    editor.on('nodeSelected', function (id) {
        console.log("Node selected " + id);
    })

    editor.on('nodeDataChanged', function (id) {
        console.log("Node changed " + id);
        const node = editor.getNodeFromId(id);
        console.log(node.data);
        console.log(mapNodeDependencies[id])
        if (mapNodeDependencies[id] !== undefined) {
            for (let i = 0; i < mapNodeDependencies[id]['source'].length; i++) {
                const dependantNode = editor.getNodeFromId(mapNodeDependencies[id]['source'][i]);
                if (dependantNode.name === 'transition') {
                    if (node.data.name !== undefined) {
                        dependantNode.data.source = node.data.name;
                        editor.updateNodeDataFromId(mapNodeDependencies[id]['source'][i], dependantNode.data);
                    }
                }
            }
            for (let i = 0; i < mapNodeDependencies[id]['target'].length; i++) {
                const dependantNode = editor.getNodeFromId(mapNodeDependencies[id]['target'][i]);
                if (dependantNode.name === 'transition') {
                    if (node.data.name !== undefined) {
                        dependantNode.data.target = node.data.name;
                        editor.updateNodeDataFromId(mapNodeDependencies[id]['target'][i], dependantNode.data);
                    }
                }
            }
            for (let i = 0; i < mapNodeDependencies[id]['event'].length; i++) {
                const dependantNode = editor.getNodeFromId(mapNodeDependencies[id]['event'][i]);
                if (dependantNode.name === 'transition') {
                    if (node.data.name !== undefined) {
                        dependantNode.data.event = node.data.name;
                        editor.updateNodeDataFromId(mapNodeDependencies[id]['event'][i], dependantNode.data);
                    }
                }
            }
        }
    })

    editor.on('moduleCreated', function (name) {
        console.log("Module Created " + name);
    })

    editor.on('moduleChanged', function (name) {
        console.log("Module Changed " + name);
    })

    editor.on('connectionCreated', function (connection) {
        console.log('Connection created');
        console.log(connection);

        const inputNodeInfo = editor.getNodeFromId(connection.input_id);
        const outputNodeInfo = editor.getNodeFromId(connection.output_id);

        if (mapNodeDependencies[connection.output_id] === undefined) {
            mapNodeDependencies[connection.output_id] = [];
            mapNodeDependencies[connection.output_id]['source'] = [];
            mapNodeDependencies[connection.output_id]['target'] = [];
            mapNodeDependencies[connection.output_id]['event'] = [];
        }

        if (mapNodeDependencies[connection.input_id] === undefined) {
            mapNodeDependencies[connection.input_id] = [];
            mapNodeDependencies[connection.input_id]['source'] = [];
            mapNodeDependencies[connection.input_id]['target'] = [];
            mapNodeDependencies[connection.input_id]['event'] = [];
        }

        if (outputNodeInfo.name === 'state') {
            if (inputNodeInfo.name === 'state') {
                // a state cannot be linked directly to another atate
                // TODO: implement some alert/notification
                const removeConnectionInfo = outputNodeInfo.outputs[connection.output_class].connections.pop();
                editor.removeSingleConnection(connection.output_id, removeConnectionInfo.node, connection.output_class, removeConnectionInfo.output);
                return;
            }
            if (inputNodeInfo.name === 'transition') {
                inputNodeInfo.data.source = outputNodeInfo.data.name ?? '';
                editor.updateNodeDataFromId(connection.input_id, inputNodeInfo.data);
                mapNodeDependencies[connection.output_id]['source'].push(connection.input_id);
            }
        }

        if (outputNodeInfo.name === 'transition') {
            if (inputNodeInfo.name === 'state') {
                outputNodeInfo.data.target = inputNodeInfo.data.name ?? '';
                editor.updateNodeDataFromId(connection.output_id, outputNodeInfo.data);
                mapNodeDependencies[connection.input_id]['target'].push(connection.output_id);
            }
            if (inputNodeInfo.name === 'event') {
                outputNodeInfo.data.event = inputNodeInfo.data.name ?? '';
                editor.updateNodeDataFromId(connection.output_id, outputNodeInfo.data);
                mapNodeDependencies[connection.input_id]['event'].push(connection.output_id);
            }
        }

        if (outputNodeInfo.name === 'condition') {
            // a condition can only have 2 connections
            // TODO: implement some alert/notification
            if (outputNodeInfo.outputs[connection.output_class].connections.length > 2) {
                const removeConnectionInfo = outputNodeInfo.outputs[connection.output_class].connections.pop();
                editor.removeSingleConnection(connection.output_id, removeConnectionInfo.node, connection.output_class, removeConnectionInfo.output);
                return;
            }
        }


        console.log(mapNodeDependencies)
        console.log(inputNodeInfo.name);
        if (inputNodeInfo.name === 'transition' && outputNodeInfo.name === 'state') {

        }
        if (inputNodeInfo.name === 'transition' && outputNodeInfo.name === 'event') {
            editor.updateNodeDataFromId(connection.output_id, {event: outputNodeInfo.data.name});
        }

        // let sourceNode = editor.getNodeFromId(connection.output_id);
        // let targetNode = editor.getNodeFromId(connection.input_id);
        // if (sourceNode.name === 'state' && targetNode.name === 'transition') {
        //     editor.updateNodeDataFromId(connection.input_id, { source: sourceNode.data.name });
        // }
        // if (sourceNode.name === 'transition' && targetNode.name === 'event') {
        //     editor.updateNodeDataFromId(connection.output_id, { event: targetNode.data.name });
        // }

        // console.log(sourceNode, targetNode);

    })

    editor.on('connectionRemoved', function (connection) {
        console.log('Connection removed');
        console.log(connection);

        const inputNodeInfo = editor.getNodeFromId(connection.input_id);
        const outputNodeInfo = editor.getNodeFromId(connection.output_id);
        if (mapNodeDependencies[connection.output_id] !== undefined) {
            let toRemove = mapNodeDependencies[connection.output_id].indexOf(connection.input_id);
            if (toRemove !== -1) {
                mapNodeDependencies[connection.output_id].splice(toRemove, 1);
            }
        }
        console.log(mapNodeDependencies)
    })

    editor.on('mouseMove', function (position) {
        // console.log('Position mouse x:' + position.x + ' y:' + position.y);
    })

    editor.on('nodeMoved', function (id) {
        console.log("Node moved " + id);
        let nodeData = editor.getNodeFromId(id);
        console.log(nodeData);
        if (combinedStatesData[nodeData.data.name] === undefined) {
            combinedStatesData[nodeData.data.name] = [];
        }

        if (nodeData.name === 'state') {
            combinedStatesData[nodeData.data.name]['posX'] = nodeData.pos_x;
            combinedStatesData[nodeData.data.name]['posY'] = nodeData.pos_y;
        }
        console.log(nodeData.data);
    })

    editor.on('zoom', function (zoom) {
        console.log('Zoom level ' + zoom);
    })

    editor.on('translate', function (position) {
        // console.log('Translate x:' + position.x + ' y:' + position.y);
    })

    editor.on('addReroute', function (id) {
        console.log("Reroute added " + id);
    })

    editor.on('removeReroute', function (id) {
        console.log("Reroute removed " + id);
    })

    /* DRAG EVENT */

    /* Mouse and Touch Actions */

    var elements = document.getElementsByClassName('drag-drawflow');
    for (var i = 0; i < elements.length; i++) {
        elements[i].addEventListener('touchend', drop, false);
        elements[i].addEventListener('touchmove', positionMobile, false);
        elements[i].addEventListener('touchstart', drag, false);
    }

    var mobile_item_selec = '';
    var mobile_last_move = null;

    function positionMobile(ev) {
        mobile_last_move = ev;
    }

    function allowDrop(ev) {
        ev.preventDefault();
    }

    function drag(ev) {
        if (ev.type === "touchstart") {
            mobile_item_selec = ev.target.closest(".drag-drawflow").getAttribute('data-node');
        } else {
            ev.dataTransfer.setData("node", ev.target.getAttribute('data-node'));
        }
    }

    function drop(ev) {
        if (ev.type === "touchend") {
            var parentdrawflow = document.elementFromPoint(mobile_last_move.touches[0].clientX, mobile_last_move.touches[0].clientY).closest("#drawflow");
            if (parentdrawflow != null) {
                addNodeToDrawFlow(mobile_item_selec, mobile_last_move.touches[0].clientX, mobile_last_move.touches[0].clientY);
            }
            mobile_item_selec = '';
        } else {
            ev.preventDefault();
            var data = ev.dataTransfer.getData("node");
            addNodeToDrawFlow(data, ev.clientX, ev.clientY);
        }

    }

    function addNodeToDrawFlow(name, pos_x, pos_y) {
        if (editor.editor_mode === 'fixed') {
            return false;
        }
        pos_x = pos_x * (editor.precanvas.clientWidth / (editor.precanvas.clientWidth * editor.zoom)) - (editor.precanvas.getBoundingClientRect().x * (editor.precanvas.clientWidth / (editor.precanvas.clientWidth * editor.zoom)));
        pos_y = pos_y * (editor.precanvas.clientHeight / (editor.precanvas.clientHeight * editor.zoom)) - (editor.precanvas.getBoundingClientRect().y * (editor.precanvas.clientHeight / (editor.precanvas.clientHeight * editor.zoom)));


        switch (name) {
            case 'state':
                editor.addNode('state', 1, 1, pos_x, pos_y, '', {}, htmlState);
                break;
            case 'condition':
                editor.addNode('condition', 1, 1, pos_x, pos_y, '', {}, htmlCondition);
                break;
            case 'transition':
                editor.addNode('transition', 1, 1, pos_x, pos_y, '', {}, htmlTransition);
                break;
            case 'event':
                editor.addNode('event', 1, 1, pos_x, pos_y, '', {}, htmlEvent);
                break;


            default:
        }
    }

    const upload = async (event) => {

        // Convert the FileList into an array and iterate
        let files = Array.from(event.target.files).map(file => {

            // Define a new file reader
            let reader = new FileReader();

            // Create a new promise
            return new Promise(resolve => {

                // Resolve the promise after reading file
                reader.onload = () => resolve(reader.result);

                // Read the file as a text
                reader.readAsText(file);

            });

        });

        // At this point you'll have an array of results
        let res = await Promise.all(files);

        for (let index = 0; index < res.length; index++) {
            const element = res[index];
            let textarea = document.createElement('textarea');
            textarea.setAttribute('class', 'xml');
            textarea.innerText = element;
            document.getElementById('textareas').appendChild(textarea);
        }
    }


    // changes on connector lines design
    // editor.curvature = 0;
    // editor.reroute_curvature_start_end = 0;
    // editor.reroute_curvature = 0;

    // editor.createCurvature = function(start_pos_x, start_pos_y, end_pos_x, end_pos_y, curvature_value) {
    //   var center_x = ((end_pos_x - start_pos_x)/2)+start_pos_x;
    //   return ' M ' + start_pos_x + ' ' + start_pos_y + ' L '+ center_x +' ' +  start_pos_y  + ' L ' + center_x + ' ' +  end_pos_y  + ' L ' + end_pos_x + ' ' + end_pos_y;
    // }

    // editor.createCurvature = function (start_pos_x, start_pos_y, end_pos_x, end_pos_y, curvature_value) {
    //     if (end_pos_y > start_pos_y) {

    //         var center_y = ((end_pos_y - start_pos_y) / 2) + start_pos_y;
    //         return ' M ' + start_pos_x + ' ' + start_pos_y + ' L ' + start_pos_x + ' ' + center_y + ' L ' + end_pos_x + ' ' + center_y + ' L ' + end_pos_x + ' ' + end_pos_y;

    //     } else {

    //         // New curvature
    //         return ' M ...';
    //     }
    // }


    // detect click on connector line and get source and target nodes
    var connectionSourceNodeId = -1;
    var connectionTargetNodeId = -1;
    editor.on('click', function (e) {
        if (e.detail === 2 && e.target.classList[0] === "main-path") {
            // // console.log(editor.connection_selected);
            // // console.log(e.path[1]);

            let nodeArray = e.path[1].getAttribute('class').split(' ');

            for (let index = 0; index < nodeArray.length; index++) {
                const element = nodeArray[index];

                if (element.indexOf('node_in_node-') !== -1) {
                    connectionTargetNodeId = element.split('-')[1];
                }

                if (element.indexOf('node_out_node-') !== -1) {
                    connectionSourceNodeId = element.split('-')[1];
                }
            }

            // console.log(connectionSourceNodeId, connectionTargetNodeId);
        }
    });
</script>
</body>

</html>
