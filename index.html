<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=720, initial-scale=1.0">
    <title>OMS Converter</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fast-xml-parser/4.0.12/fxparser.min.js"
            integrity="sha512-HGrrIN/LyGNpsITQqS0Oz+0rCFt/+2/eymCPchz/Pvx8JofaxmLfoEJNIix9R1iHEnScT+HSt8WBifDINQu89g=="
            crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/js/all.min.js"
            integrity="sha256-KzZiKy0DWYsnwMF+X1DvQngQ2/FxF7MF3Ff72XcpuPs=" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.13.0/css/all.min.css"
          integrity="sha256-h20CPZ0QyXlBuAw7A+KluUYx/3pK+c7lYEpqLTlxjYQ=" crossorigin="anonymous"/>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/jerosoler/Drawflow/dist/drawflow.min.css">
    <script src="https://cdn.jsdelivr.net/gh/jerosoler/Drawflow/dist/drawflow.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/micromodal/dist/micromodal.min.js"></script>

    <style>
        :root {
            --border-color: #cacaca;
            --background-color: #ffffff;

            --background-box-title: #f7f7f7;
        }

        html,
        body {
            margin: 0px;
            padding: 0px;
            width: 100vw;
            height: 100vh;
            /* overflow: hidden; */
            font-family: 'Roboto', sans-serif;
        }

        header {
            height: 66px;
            border-bottom: 1px solid var(--border-color);
            padding-left: 20px;
        }

        header h2 {
            margin: 0px;
            line-height: 66px;
        }

        header a {
            color: black;
        }

        .wrapper {
            width: 100%;
            height: calc(100vh - 67px);
            display: flex;
        }

        .col {
            overflow: auto;
            width: 300px;
            height: 100%;
            border-right: 1px solid var(--border-color);
        }

        .drag-drawflow {
            line-height: 50px;
            border-bottom: 1px solid var(--border-color);
            padding-left: 20px;
            cursor: move;
            user-select: none;
        }

        #drawflow {
            position: relative;
            width: calc(100vw - 301px);
            height: calc(100% - 50px);
            top: 40px;
            background: var(--background-color);
            background-size: 25px 25px;
            background-image: linear-gradient(to right, #f1f1f1 1px, transparent 1px),
            linear-gradient(to bottom, #f1f1f1 1px, transparent 1px);
        }

        @media only screen and (max-width: 768px) {
            .col {
                width: 50px;
            }

            .col .drag-drawflow span {
                display: none;
            }

            #drawflow {
                width: calc(100vw - 51px);
            }
        }


        /* Editing Drawflow */

        .drawflow .drawflow-node {
            background: var(--background-color);
            /*border: 1px solid var(--border-color);*/
            -webkit-box-shadow: 0 2px 15px 2px var(--border-color);
            box-shadow: 0 2px 15px 2px var(--border-color);
            padding: 0px;
            width: 200px;
            border-radius: 10px;
            border: 4px solid #305A72;
        }

        .drawflow .drawflow-node.selected {
            background: white;
            border: 4px solid #4ea9ff;
            -webkit-box-shadow: 0 2px 20px 2px #4ea9ff;
            box-shadow: 0 2px 20px 2px #4ea9ff;
        }

        .drawflow .drawflow-node.selected .title-box {
            color: #22598c;
            /*border-bottom: 1px solid #4ea9ff;*/
        }

        .drawflow .connection .main-path {
            stroke: #4ea9ff;
            stroke-width: 3px;
        }

        .drawflow .drawflow-node .input,
        .drawflow .drawflow-node .output {
            height: 15px;
            width: 15px;
            border: 2px solid var(--border-color);
        }

        .drawflow .drawflow-node .input:hover,
        .drawflow .drawflow-node .output:hover {
            background: #4ea9ff;
        }

        .drawflow .drawflow-node .output {
            right: 10px;
        }

        .drawflow .drawflow-node .input {
            left: -10px;
            background: white;
        }

        .drawflow > .drawflow-delete {
            border: 2px solid #43b993;
            background: white;
            color: #43b993;
            -webkit-box-shadow: 0 2px 20px 2px #43b993;
            box-shadow: 0 2px 20px 2px #43b993;
        }

        .drawflow-delete {
            border: 2px solid #4ea9ff;
            background: white;
            color: #4ea9ff;
            -webkit-box-shadow: 0 2px 20px 2px #4ea9ff;
            box-shadow: 0 2px 20px 2px #4ea9ff;
        }

        .drawflow-node .title-box {
            height: 50px;
            line-height: 50px;
            background: var(--background-box-title);
            border-bottom: 1px solid #e9e9e9;
            border-radius: 4px 4px 0px 0px;
            padding-left: 10px;
        }

        .drawflow .title-box svg {
            position: initial;
        }

        .drawflow-node .box {
            padding: 10px 20px 20px 20px;
            font-size: 14px;
            color: #555555;

        }

        .drawflow-node .box p {
            margin-top: 5px;
            margin-bottom: 5px;
        }

        .drawflow-node.welcome {
            width: 250px;
        }

        .drawflow-node.slack .title-box {
            border-radius: 4px;
        }

        .drawflow-node input,
        .drawflow-node select,
        .drawflow-node textarea {
            border-radius: 4px;
            border: 1px solid var(--border-color);
            height: 30px;
            line-height: 30px;
            font-size: 16px;
            width: 158px;
            color: #555555;
        }

        .drawflow-node textarea {
            height: 100px;
        }


        .drawflow-node.personalized {
            background: red;
            height: 200px;
            text-align: center;
            color: white;
        }

        .drawflow-node.personalized .input {
            background: yellow;
        }

        .drawflow-node.personalized .output {
            background: green;
        }

        .drawflow-node.personalized.selected {
            background: blue;
        }

        .drawflow .connection .point {
            stroke: var(--border-color);
            stroke-width: 2;
            fill: white;

        }

        .drawflow .connection .point.selected,
        .drawflow .connection .point:hover {
            fill: #4ea9ff;
        }


        @media only screen and (max-width: 768px) {
            .modal-content {
                width: 80%;
            }
        }

        .happy {
            background-color: #ebf2eb;
        }

        .event {
            background-color: #ecf0f5;
        }

        .transition {
            background-color: #FFF4BD;
        }


        /* Vertical connectors */
        .drawflow .drawflow-node {
            display: block;
        }

        .drawflow .drawflow-node .inputs,
        .drawflow .drawflow-node .outputs {
            display: flex;
            width: auto;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 0;
        }

        .drawflow .drawflow-node .input {
            top: 0px;
            left: 0px;
        }

        .drawflow .drawflow-node .output {
            top: 0px;
            right: 0px;
        }

        /* handlding SVG */
        .drawflow-node.shape {
            background: transparent;
            border: 0px;
            pointer-events: none;
        }

        .drawflow-node.shape.selected {
            background: transparent;
        }

        .drawflow-node.shape polygon {
            pointer-events: all;
        }

        .drawflow-node.shape .input,
        .drawflow-node.shape .output {
            pointer-events: all;
        }

        .drawflow-node.shape .inputs .input_1 {
            top: 187px;
            left: -10px;
        }

        .drawflow-node.shape .outputs .output_1 {
            top: 7px;
            left: 13px;
        }

        /*  hide uploaded textareas  */
        .xml {
            display: none;
        }

        .state {
            /*border-radius: 10px;*/
            /*border: 4px solid #305A72;*/
            height: 100px;
            width: 200px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
        }

        .drawflow .parent-node .romb {
            transform: rotate(45deg);
            width: 200px;
            height: 200px;
            display: flex;
        }

        .drawflow .parent-node .romb .drawflow_content_node {
            transform: rotate(-45deg);
            height: 100px;
        }

        .drawflow .parent-node .romb .input_1 {
            transform: rotate(-45deg);
            position: relative;
            top: 100px;
            left: 20px;
        }

        .drawflow .parent-node .romb .output_1 {
            transform: rotate(-45deg);
            position: relative;
            top: -100px;
            right: 0px;
        }

        .drawflow .parent-node .romb .output_2 {
            transform: rotate(-45deg);
            position: relative;
            top: 100px;
            right: 20px;
        }

        .drawflow .parent-node .romb .output_3 {
            transform: rotate(-45deg);
            position: relative;
            top: 10px;
            right: 0px;
        }


        /*  modal */
        /**************************\
          Basic Modal Styles
        \**************************/

        .modal {
            font-family: -apple-system, BlinkMacSystemFont, avenir next, avenir, helvetica neue, helvetica, ubuntu, roboto, noto, segoe ui, arial, sans-serif;
        }

        .modal__overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.6);
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .modal__container {
            background-color: #fff;
            padding: 30px;
            max-width: 500px;
            max-height: 100vh;
            border-radius: 4px;
            overflow-y: auto;
            box-sizing: border-box;
        }

        .modal__header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal__title {
            margin-top: 0;
            margin-bottom: 0;
            font-weight: 600;
            font-size: 1.25rem;
            line-height: 1.25;
            color: #00449e;
            box-sizing: border-box;
        }

        .modal__close {
            background: transparent;
            border: 0;
        }

        .modal__header .modal__close:before {
            content: "\2715";
        }

        .modal__content {
            margin-top: 2rem;
            margin-bottom: 2rem;
            line-height: 1.5;
            color: rgba(0, 0, 0, .8);
        }

        .modal__btn {
            font-size: .875rem;
            padding-left: 1rem;
            padding-right: 1rem;
            padding-top: .5rem;
            padding-bottom: .5rem;
            background-color: #e6e6e6;
            color: rgba(0, 0, 0, .8);
            border-radius: .25rem;
            border-style: none;
            border-width: 0;
            cursor: pointer;
            -webkit-appearance: button;
            text-transform: none;
            overflow: visible;
            line-height: 1.15;
            margin: 0;
            will-change: transform;
            -moz-osx-font-smoothing: grayscale;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            -webkit-transform: translateZ(0);
            transform: translateZ(0);
            transition: -webkit-transform .25s ease-out;
            transition: transform .25s ease-out;
            transition: transform .25s ease-out, -webkit-transform .25s ease-out;
        }

        .modal__btn:focus, .modal__btn:hover {
            -webkit-transform: scale(1.05);
            transform: scale(1.05);
        }

        .modal__btn-primary {
            background-color: #00449e;
            color: #fff;
        }


        /**************************\
          Demo Animation Style
        \**************************/
        @keyframes mmfadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes mmfadeOut {
            from {
                opacity: 1;
            }
            to {
                opacity: 0;
            }
        }

        @keyframes mmslideIn {
            from {
                transform: translateY(15%);
            }
            to {
                transform: translateY(0);
            }
        }

        @keyframes mmslideOut {
            from {
                transform: translateY(0);
            }
            to {
                transform: translateY(-10%);
            }
        }

        .micromodal-slide {
            display: none;
        }

        .micromodal-slide.is-open {
            display: block;
        }

        .micromodal-slide[aria-hidden="false"] .modal__overlay {
            animation: mmfadeIn .3s cubic-bezier(0.0, 0.0, 0.2, 1);
        }

        .micromodal-slide[aria-hidden="false"] .modal__container {
            animation: mmslideIn .3s cubic-bezier(0, 0, .2, 1);
        }

        .micromodal-slide[aria-hidden="true"] .modal__overlay {
            animation: mmfadeOut .3s cubic-bezier(0.0, 0.0, 0.2, 1);
        }

        .micromodal-slide[aria-hidden="true"] .modal__container {
            animation: mmslideOut .3s cubic-bezier(0, 0, .2, 1);
        }

        .micromodal-slide .modal__container,
        .micromodal-slide .modal__overlay {
            will-change: transform;
        }    </style>
</head>

<body>
<h1>OMS Converter</h1>
<input onchange='upload(event)' type='file' multiple/>
<button onclick="process()">Process</button>
<br>
<div id="textareas"></div>

<hr>
OMS Process name: <input type="text" name="processName">
<button onclick="exportGraph()">Export</button>
<br>
<textarea name="xml" style="display: none" id="export" cols="100" rows="20"></textarea>
<textarea name="xml" id="exportXml" cols="100" rows="20"></textarea>
<hr>


<div class="wrapper">
    <div class="col">
        <div class="drag-drawflow" draggable="true" ondragstart="drag(event)" data-node="state">
            <i class="fa fa-cogs"></i><span> State</span>
        </div>
        <div class="drag-drawflow" draggable="true" ondragstart="drag(event)" data-node="condition">
            <i class="fa fa-question-circle"></i><span> Condition</span>
        </div>
        <!--
        <div class="drag-drawflow" draggable="true" ondragstart="drag(event)" data-node="transition">
            <i class="fa fa-exchange-alt"></i><span> Transition</span>
        </div>
        <div class="drag-drawflow" draggable="true" ondragstart="drag(event)" data-node="event">
            <i class="fa fa-bolt"></i><span> Event</span>
        </div>
        -->
    </div>
    <div class="col-right">
        <div id="drawflow" ondrop="drop(event)" ondragover="allowDrop(event)"></div>
    </div>
</div>


<div class="modal micromodal-slide" id="modal-state" aria-hidden="true">
    <div class="modal__overlay" tabindex="-1" data-micromodal-close>
        <div class="modal__container" role="dialog" aria-modal="true" aria-labelledby="modal-state-title">
            <header class="modal__header">
                <h2 class="modal__title" id="modal-state-title">
                    State
                    <input type="hidden" name="state-nodeId" id="state-nodeId">
                </h2>
                <button class="modal__close" aria-label="Close modal" data-micromodal-close></button>
            </header>
            <main class="modal__content" id="modal-state-content">
                <p>Try hitting the <code>tab</code> key and notice how the focus stays within the modal itself. Also, <code>esc</code> to close modal</p>
                <p>
                <p>Name</p>
                <input type="text" id="state-name">
                <p>Reserved</p>
                <select id="state-reserved">
                    <option value="">Select</option>
                    <option value="true">true</option>
                    <option value="false">false</option>
                </select>
                <p>Flag</p>
                <input type="text" id="state-flag">
                <p>Display</p>
                <input type="text" id="state-display">
                </p>
            </main>
            <footer class="modal__footer">
                <button class="modal__btn modal__btn-primary" onclick="createOrUpdateStateData()">Continue</button>
                <button class="modal__btn" data-micromodal-close aria-label="Close this dialog window">Close</button>
            </footer>
        </div>
    </div>
</div>
<div class="modal micromodal-slide" id="modal-transition" aria-hidden="true">
    <div class="modal__overlay" tabindex="-1" data-micromodal-close>
        <div class="modal__container" role="dialog" aria-modal="true" aria-labelledby="modal-transition-title">
            <header class="modal__header">
                <h2 class="modal__title" id="modal-transition-title">
                    Transition
                </h2>
                <button class="modal__close" aria-label="Close modal" data-micromodal-close></button>
            </header>
            <main class="modal__content" id="modal-transition-content">
                <p>
                <p>Event</p>
                <input type="text" df-event>
                <p>Source</p>
                <input type="text" df-source>
                <p>Target</p>
                <input type="text" df-target>
                <p>Condition</p>
                <input type="text" df-condition>
                <p>Happy</p>
                <select name="df-happy" onchange="changeOption(event)">
                    <option value="">Select</option>
                    <option value="true">true</option>
                    <option value="false">false</option>
                </select>

                </p>
                <p>
                <p>Name</p>
                <input type="text" df-name>
                <p>Command</p>
                <input type="text" df-command>
                <p>onEnter</p>
                <!--                <input type="text" df-onEnter>-->
                <select name="df-onEnter" onchange="changeOption(event)">
                    <option value="">Select</option>
                    <option value="true">true</option>
                    <option value="false">false</option>
                </select>
                <p>Manual</p>
                <!--                <input type="text" df-manual>-->
                <select name="df-manual" onchange="changeOption(event)">
                    <option value="">Select</option>
                    <option value="true">true</option>
                    <option value="false">false</option>
                </select>
                <p>Timeout</p>
                <input type="text" df-timeout>
                <p>Timeout Processor</p>
                <input type="text" df-timeoutProcessor>

                </p>
            </main>
            <footer class="modal__footer">
                <button class="modal__btn modal__btn-primary">Continue</button>
                <button class="modal__btn" data-micromodal-close aria-label="Close this dialog window">Close</button>
            </footer>
        </div>
    </div>
</div>
<div class="modal micromodal-slide" id="modal-condition" aria-hidden="true">
    <div class="modal__overlay" tabindex="-1" data-micromodal-close>
        <div class="modal__container" role="dialog" aria-modal="true" aria-labelledby="modal-condition-title">
            <header class="modal__header">
                <h2 class="modal__title" id="modal-condition-title">
                    Condition
                </h2>
                <button class="modal__close" aria-label="Close modal" data-micromodal-close></button>
            </header>
            <main class="modal__content" id="modal-condition-content">
                <p>
                <p>Name</p>
                <input type="text" df-name>
                <p>Happy</p>
                <select name="df-happy" onchange="changeOption(event)">
                    <option value="">Select</option>
                    <option value="true">true</option>
                    <option value="false">false</option>
                </select>
                </p>
            </main>
            <footer class="modal__footer">
                <button class="modal__btn modal__btn-primary">Continue</button>
                <button class="modal__btn" data-micromodal-close aria-label="Close this dialog window">Close</button>
            </footer>
        </div>
    </div>
</div>
<script>
    let id = document.getElementById("drawflow");
    const editor = new Drawflow(id);

    // editor.reroute = true;
    editor.editor_mode = 'edit'; // Default
    editor.start();

    let mapNodeStateElement = [];
    let mapNodeEventElement = [];
    let mapNodeTransitionElement = [];
    let mapNodeConditionElement = [];
    let mapNodePositions = [];
    let mapNodeConnectedThruConditions = [];

    let combinedEventsData = [];
    let combinedStatesData = [];
    let combinedTransitionsData = [];
    let combinedConditionsData = [];

    let alreadyPositioned = [];
    let mapNodeDependencies = [];

    function changeOption(e) {
        return;
        const id = e.target.closest(".drawflow-node").id.slice(5);
        const field = e.target.name.split('-')[1];
        const value = e.target.value;
        const node = editor.getNodeFromId(id);
        const data = node.data;
        if (node.name === 'state') {
            data['reserved'] = value;
        }
        if (node.name === 'transition') {
            data['happy'] = value;
        }
        if (node.name === 'event') {
            data[field] = value;
        }

        editor.updateNodeDataFromId(id, data);
    }

    let htmlState = `<div class="state">
            <div class="title-box"><i class="fa fa-cogs"></i> State</div>
            <div class="box happy" >
                <p>Name</p>
                <input type="text" df-name>
                <p>Reserved</p>
                <select name="df-reserved" onchange="changeOption(event)">
                    <option value="">Select</option>
                    <option value="true">true</option>
                    <option value="false">false</option>
                </select>
                <p>Flag</p>
                <input type="text" df-flag>
                <p>Display</p>
                <input type="text" df-display>
            </div>
          </div>`;

    htmlState = `
        <div class="state" ondblclick="showpopup(event)">
            ==content==
        </div>`;
    //   var htmlState = `<div class="shape"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64" fill="#fff" fill-rule="evenodd" stroke="#000" stroke-linecap="round" stroke-linejoin="round"><path d="M54.5 24.5h-45C5.345 24.5 2 27.845 2 32s3.345 7.5 7.5 7.5h45c4.155 0 7.5-3.345 7.5-7.5s-3.345-7.5-7.5-7.5z" stroke="#838383" fill="#efc"/><input type="text" df-name></svg></div>`;
    //   var htmlState = `<div class="shape"><svg xmlns="http://www.w3.org/2000/svg" xmlns:inkscape="http://www.inkscape.org/namespaces/inkscape" xmlns:sodipodi="http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd" xmlns:xlink="http://www.w3.org/1999/xlink" id="svg548" inkscape:version="0.38.1" sodipodi:docbase="/var/www/html/svg_gallery/svg/flowcharts" sodipodi:docname="fc15.svg" sodipodi:version="0.32" viewBox="15.12 72.22 469.66 361.17">  <metadata>    <rdf:RDF xmlns:cc="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">      <cc:Work rdf:about="">        <dc:title>Clipart by Nicu Buculei - fc23</dc:title>        <dc:description></dc:description>        <dc:subject>          <rdf:Bag>            <rdf:li>flowchart</rdf:li>            <rdf:li></rdf:li>            <rdf:li>shape</rdf:li>          </rdf:Bag>        </dc:subject>        <dc:publisher>          <cc:Agent rdf:about="http://www.openclipart.org">            <dc:title>Nicu Buculei</dc:title>          </cc:Agent>        </dc:publisher>        <dc:creator>          <cc:Agent>            <dc:title>Nicu Buculei</dc:title>          </cc:Agent>        </dc:creator>        <dc:rights>          <cc:Agent>            <dc:title>Nicu Buculei</dc:title>          </cc:Agent>        </dc:rights>        <dc:date></dc:date>        <dc:format>image/svg+xml</dc:format>        <dc:type rdf:resource="http://purl.org/dc/dcmitype/StillImage"></dc:type>        <cc:license rdf:resource="http://web.resource.org/cc/PublicDomain"></cc:license>        <dc:language>en</dc:language>      </cc:Work>      <cc:License rdf:about="http://web.resource.org/cc/PublicDomain">        <cc:permits rdf:resource="http://web.resource.org/cc/Reproduction"></cc:permits>        <cc:permits rdf:resource="http://web.resource.org/cc/Distribution"></cc:permits>        <cc:permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"></cc:permits>      </cc:License>    </rdf:RDF>  </metadata>  <defs id="defs550"></defs>  <sodipodi:namedview id="base" inkscape:cx="197.75166" inkscape:cy="200.00000" inkscape:window-height="500" inkscape:window-width="400" inkscape:window-x="5" inkscape:window-y="46" inkscape:zoom="0.77250000" showgrid="true"></sodipodi:namedview>  <g id="g827">    <path d="M 67.369808,93.462270 L 449.01471,95.410270 C 449.01471,95.410270 486.60595,152.87637 484.70250,255.14737 C 484.76992,368.13237 450.91816,431.44237 450.91816,431.44237 L 68.321534,433.39037 C 68.321534,433.39037 31.203905,370.08037 35.010811,255.14737 C 34.059085,146.05937 66.418081,94.436270 67.369808,93.462270 z " id="path1546" sodipodi:nodetypes="ccccccc" style="fill:#000000;fill-rule:evenodd;stroke:none;stroke-opacity:1;stroke-width:3.75;stroke-linejoin:miter;stroke-linecap:butt;fill-opacity:0.25;stroke-dasharray:none;"></path>    <path d="M 51.6224 56.8269 L 442.199 58.7749 C 442.199 58.7749 480.67 116.241 478.722 218.512 C 478.791 331.497 444.147 394.807 444.147 394.807 L 52.5964 396.755 C 52.5964 396.755 14.6101 333.445 18.5061 218.512 C 17.5321 109.424 50.6484 57.8009 51.6224 56.8269 z " id="path605" sodipodi:nodetypes="ccccccc" style="fill:#ffffff;fill-rule:evenodd;stroke:black;stroke-opacity:1;stroke-width:10.116339;stroke-linejoin:round;stroke-linecap:butt;fill-opacity:1;stroke-dasharray:none;" transform="matrix(0.977132,0.000000,0.000000,1.000000,2.364802,20.45414)"></path>    <text x="0" y="50" font-family="Verdana" font-size="35" fill="blue">Hello</text></g></svg></div>`;
    //   var htmlState = `<div class="shape"><svg xmlns="http://www.w3.org/2000/svg" fill="#fff" fill-rule="evenodd" stroke="#000" stroke-linecap="round" stroke-linejoin="round" viewBox="1.5 24 61 16"><path d="M54.5 24.5h-45C5.345 24.5 2 27.845 2 32s3.345 7.5 7.5 7.5h45c4.155 0 7.5-3.345 7.5-7.5s-3.345-7.5-7.5-7.5z" stroke="#838383" fill="#efc"></path></svg></div>`;

    let htmlTransition = `<div>
            <div class="title-box"><i class="fa fa-exchange-alt"></i> Transition</div>
            <div class="box transition" >
                <p>Event</p>
                <input type="text" df-event>
                <p>Source</p>
                <input type="text" df-source>
                <p>Target</p>
                <input type="text" df-target>
                <p>Condition</p>
                <input type="text" df-condition>
                <p>Happy</p>
                <select name="df-happy" onchange="changeOption(event)">
                    <option value="">Select</option>
                    <option value="true">true</option>
                    <option value="false">false</option>
                </select>
            </div>
          </div>`;

    let htmlCondition = `
        <div class="state" ondblclick="showpopup(event)">
          ==content==
        </div>
        `;
    let htmlEvent = `<div>
            <div class="title-box"><i class="fa fa-bolt"></i> Event</div>
            <div class="box event" >
                <p>Name</p>
                <input type="text" df-name>
                <p>Command</p>
                <input type="text" df-command>
                <p>onEnter</p>
<!--                <input type="text" df-onEnter>-->
                <select name="df-onEnter" onchange="changeOption(event)">
                    <option value="">Select</option>
                    <option value="true">true</option>
                    <option value="false">false</option>
                </select>
                <p>Manual</p>
<!--                <input type="text" df-manual>-->
                <select name="df-manual" onchange="changeOption(event)">
                    <option value="">Select</option>
                    <option value="true">true</option>
                    <option value="false">false</option>
                </select>
                <p>Timeout</p>
                <input type="text" df-timeout>
                <p>Timeout Processor</p>
                <input type="text" df-timeoutProcessor>
            </div>
          </div>`;

    editor.on('nodeCreated', function (id) {
        // console.log("Node created " + id);
        let nodeData = editor.getNodeFromId(id);

        let nodeDataName = nodeData.data.name ?? '';
        if (nodeData.name === 'state') {
            console.log("Node state created " + id);
            if (combinedStatesData[nodeDataName] === undefined) {
                combinedStatesData[nodeDataName] = [];
            }

            combinedStatesData[nodeDataName]['nodeId'] = id;
            combinedStatesData[nodeDataName]['posX'] = nodeData.pos_x;
            combinedStatesData[nodeDataName]['posY'] = nodeData.pos_y;


            mapNodeStateElement[nodeDataName] = id;
        }
        if (nodeData.name === 'event') {
            // console.log("Node event created " + id);
            if (combinedEventsData[nodeDataName] === undefined) {
                combinedEventsData[nodeDataName] = [];
            }

            combinedEventsData[nodeDataName]['nodeId'] = id;
            combinedEventsData[nodeDataName]['posX'] = nodeData.pos_x;
            combinedEventsData[nodeDataName]['posY'] = nodeData.pos_y;
            combinedEventsData[nodeDataName] = id;

            mapNodeEventElement[nodeDataName] = id;

            // events have no output
            editor.removeNodeOutput(id, 'output_1');
        }

        if (nodeData.name === 'transition') {
            // console.log("Node transition created " + id);
            if (combinedTransitionsData[nodeDataName] === undefined) {
                combinedTransitionsData[nodeDataName] = [];
            }

            combinedTransitionsData[nodeDataName]['nodeId'] = id;
            combinedTransitionsData[nodeDataName]['posX'] = nodeData.pos_x;
            combinedTransitionsData[nodeDataName]['posY'] = nodeData.pos_y;
            mapNodeTransitionElement[nodeDataName] = id;
        }

        if (nodeData.name === 'condition') {
            // console.log("Node condition created " + id);
            mapNodeConditionElement[nodeDataName] = id;
        }
    })

    let processing = false;

    function process() {
        processing = true;
        editor.clear();
        const options = {
            ignoreAttributes: false,
            parseAttributeValue: true,
            allowBooleanAttributes: true
        };

        const parser = new XMLParser(options);

        let combinedEvents = [];
        let combinedStates = [];
        let combinedTransitions = [];

        let xmls = document.getElementsByClassName('xml');
        for (let index = 0; index < xmls.length; index++) {
            const element = xmls[index].value;
            const parsedElement = parser.parse(element);

            let process = parsedElement.statemachine.process;

            // handles main process
            if (parsedElement.statemachine.process.length !== undefined) {
                process = parsedElement.statemachine.process[0];
                document.getElementsByName('processName')[0].value = process['@_name'];
            }

            combinedEvents = combinedEvents.concat(process.events.event);
            combinedStates = combinedStates.concat(process.states.state);
            combinedTransitions = combinedTransitions.concat(process.transitions.transition);
        }

        for (let index = 0; index < combinedStates.length; index++) {
            const element = combinedStates[index];
            // editor.addNode('state', 1, 1, (50 + 250*index), (20 + (270 * index)), '', data, html);
            // editor.addNode('state', 1, 1, (50 + 250 * index), (20), '', data, htmlState);
            combinedStatesData[element['@_name']] = {
                "name": element['@_name'],
                "color": (element['@_reserved'] !== undefined && element['@_reserved'] === true) ? '#ebf2eb' : '#ffffff',
                "flag": (element['flag'] !== undefined) ? element['flag'] : '',
                "reserved": (element['@_reserved'] !== undefined) ? element['@_reserved'] + '' : 'false',
                "display": (element['@_display'] !== undefined) ? element['@_display'] : '',
                "nodeId": '',
                "childrenCount": 0,
                "childrenNames": [],
                "statesCount": 0,
                "stateNames": [],
            };
        }

        for (let index = 0; index < combinedEvents.length; index++) {
            const element = combinedEvents[index];
            // editor.addNode('state', 1, 1, (50 + 250*index), (20 + (270 * index)), '', data, html);
            // editor.addNode('event', 1, 1, (50 + 250 * index), (400), '', data, htmlEvent);
            combinedEventsData[element['@_name']] = {
                "name": element['@_name'],
                "timeout": (element['@_timeout'] !== undefined) ? element['@_timeout'] : '',
                "onEnter": (element['@_onEnter'] !== undefined) ? element['@_onEnter'] + '' : 'false',
                "command": (element['@_command'] !== undefined) ? element['@_command'] : '',
                "manual": (element['@_manual'] !== undefined) ? element['@_manual'] + '' : 'false',
                "timeoutProcessor": (element['@_timeoutProcessor'] !== undefined) ? element['@_timeoutProcessor'] : '',
                "nodeId": '',
                "childrenCount": 0,
                "childrenNames": [],
            };
        }

        for (let index = 0; index < combinedTransitions.length; index++) {
            const element = combinedTransitions[index];
            let data = {
                "name": (element['event'] + '-' + element['source'] + '-' + element['target']).replaceAll(' ', '-'),
                "event": element['event'],
                "source": (element['source'] !== undefined) ? element['source'] : '',
                "target": (element['target'] !== undefined) ? element['target'] : '',
                "condition": (element['@_condition'] !== undefined) ? element['@_condition'] : '',
                "happy": (element['@_happy'] !== undefined) ? element['@_happy'] + '' : 'false',
                "nodeId": '',
            };

            // handle missing parts of the available OMS
            if (combinedStatesData[element['source']] === undefined) {
                console.log(element['source'] + ' not found');
                continue;
            }
            if (combinedStatesData[element['target']] === undefined) {
                console.log(element['target'] + ' not found');
                continue;
            }

            if (element['@_condition'] !== undefined) {
                let conditionKey = (element['event'] + '-' + element['source']).replaceAll(' ', '-');
                combinedConditionsData[conditionKey] = element['@_condition'];
            }

            if (combinedStatesData[element['target']]['nodeId'] === '') {
                combinedStatesData[element['source']]['childrenCount'] += 1;
                combinedStatesData[element['source']]['childrenNames'].push(element['target']);
                combinedStatesData[element['source']]['statesCount'] += 1;
                combinedStatesData[element['source']]['stateNames'].push(element['target']);

                if (combinedEventsData[element['event']] !== undefined) {
                    combinedEventsData[element['event']]['childrenCount'] += 1;
                    combinedEventsData[element['event']]['childrenNames'].push(element['target']);
                } else {
                    console.log('Event ' + element['event'] + ' not found')
                }

                let event = element['event'].replaceAll(' ', '-');
                if (combinedStatesData[element['source']]['stateNames'][event] === undefined) {
                    combinedStatesData[element['source']]['stateNames'][event] = [];
                }
                combinedStatesData[element['source']]['stateNames'][event].push(element['target']);
            }

            combinedTransitionsData[data['name']] = data;
        }
        // console.log(combinedStatesData);
        // console.log(combinedTransitionsData);
        // console.log(combinedEventsData);

        // add states to canvas
        for (let [key, state] of Object.entries(combinedStatesData)) {
            let locHtmlState = htmlState.replaceAll('==content==', state.name);
            editor.addNode('state', 1, 1, 10, 10, '', state, locHtmlState);
        }

        // add transitions to canvas
        for (let [key, transition] of Object.entries(combinedTransitionsData)) {
            editor.addNode('transition', 1, 1, 100, 100, '', transition, htmlTransition);
        }

        for (const [stateName, state] of Object.entries(combinedStatesData)) {
            for (const [conditionName, relatedStateNames] of Object.entries(state.stateNames)) {
                if (relatedStateNames.length === 2) {
                    // add condition graph
                    let locHtmlCondition = htmlCondition.replaceAll('==content==', combinedConditionsData[(conditionName + '-' + stateName).replaceAll(' ', '-')])
                    editor.addNode('condition', 1, 2, 100, 100, 'romb state', {name: conditionName}, locHtmlCondition);

                    // add connection between source and condition
                    editor.addConnection(mapNodeStateElement[stateName], mapNodeConditionElement[conditionName], 'output_1', 'input_1');
                    for (const [key2, relatedStateName] of Object.entries(relatedStateNames)) {
                        // add connection between condition and target
                        let transitionKey = (conditionName + '-' + stateName + '-' + relatedStateName).replaceAll(' ', '-');
                        console.log(combinedTransitionsData[transitionKey])

                        // editor.addConnection(mapNodeConditionElement[conditionName], mapNodeTransitionElement[transitionKey], 'output_1', 'input_1');
                        // editor.addConnection(mapNodeTransitionElement[transitionKey], mapNodeStateElement[relatedStateName], 'output_1', 'input_1');
                        editor.addConnection(mapNodeConditionElement[conditionName], mapNodeStateElement[relatedStateName], 'output_' + (+key2 + 1), 'input_1');

                        if (combinedTransitionsData[transitionKey]['happy'] === true) {
                            let label = document.querySelector(".connection.node_in_node-" + mapNodeTransitionElement[transitionKey] + ".node_out_node-" + mapNodeConditionElement[conditionName] + ".output_1.input_1");

                            addLabelText(label, "happy");
                        }

                        if (mapNodeConnectedThruConditions[stateName] === undefined) {
                            mapNodeConnectedThruConditions[stateName] = [];
                            mapNodeConnectedThruConditions[stateName]['transitionKey'] = [];
                            mapNodeConnectedThruConditions[stateName]['conditionName'] = '';
                            mapNodeConnectedThruConditions[stateName]['states'] = [];
                        }
                        mapNodeConnectedThruConditions[stateName]['transitionKey'].push(transitionKey);
                        mapNodeConnectedThruConditions[stateName]['conditionName'] = conditionName;
                        mapNodeConnectedThruConditions[stateName]['states'][relatedStateName] = true;
                    }
                }
            }
        }

        let newCombinedStateData = [];
        if (combinedStatesData['new'] !== undefined) {
            newCombinedStateData['new'] = combinedStatesData['new']
        }

        for (const [stateName, state] of Object.entries(combinedStatesData)) {
            if (stateName === 'new') {
                continue;
            }

            newCombinedStateData[stateName] = combinedStatesData[stateName]
        }
        combinedStatesData = newCombinedStateData;

        let counter = 0;
        for (const [stateNameKey, state] of Object.entries(combinedStatesData)) {
            let stateElement = mapNodeStateElement[stateNameKey];

            if (stateNameKey === 'new') {
                editor.drawflow.drawflow.Home.data[stateElement].pos_x = 10;
                editor.drawflow.drawflow.Home.data[stateElement].pos_y = 10;
                document.getElementById("node-" + stateElement).style.top = 10 + "px";
                document.getElementById("node-" + stateElement).style.left = "10px";
                editor.updateConnectionNodes("node-" + stateElement);
            } else {
                if (alreadyPositioned.indexOf(stateNameKey) === -1) {
                    editor.drawflow.drawflow.Home.data[stateElement].pos_x = 10;
                    editor.drawflow.drawflow.Home.data[stateElement].pos_y = (10 + (500 * counter));
                    document.getElementById("node-" + stateElement).style.top = "10px";
                    document.getElementById("node-" + stateElement).style.left = (10 + (500 * counter)) + "px";
                    editor.updateConnectionNodes("node-" + stateElement);
                    counter++;
                }
            }

            for (const [conditionName, stateName] of Object.entries(state.stateNames)) {
                if (stateName.length === 2) {
                    let conditionElement = mapNodeConditionElement[conditionName];

                    editor.drawflow.drawflow.Home.data[conditionElement].pos_x = editor.drawflow.drawflow.Home.data[stateElement].pos_x + 400;
                    editor.drawflow.drawflow.Home.data[conditionElement].pos_y = editor.drawflow.drawflow.Home.data[stateElement].pos_y + 200;
                    document.getElementById("node-" + conditionElement).style.top = (editor.drawflow.drawflow.Home.data[stateElement].pos_y + 200) + "px";
                    document.getElementById("node-" + conditionElement).style.left = (editor.drawflow.drawflow.Home.data[stateElement].pos_x + 400) + "px";
                    editor.updateConnectionNodes("node-" + conditionElement);

                    let leftOption = mapNodeStateElement[stateName[0]];
                    console.log('positioning', stateName[0])
                    editor.drawflow.drawflow.Home.data[leftOption].pos_x = editor.drawflow.drawflow.Home.data[conditionElement].pos_x + 250;
                    editor.drawflow.drawflow.Home.data[leftOption].pos_y = editor.drawflow.drawflow.Home.data[conditionElement].pos_y + 300;
                    document.getElementById("node-" + leftOption).style.top = (editor.drawflow.drawflow.Home.data[conditionElement].pos_y + 300) + "px";
                    document.getElementById("node-" + leftOption).style.left = (editor.drawflow.drawflow.Home.data[conditionElement].pos_x + 250) + "px";
                    editor.updateConnectionNodes("node-" + leftOption);
                    alreadyPositioned.push(stateName[0]);
                    let rightOption = mapNodeStateElement[stateName[1]];
                    editor.drawflow.drawflow.Home.data[rightOption].pos_x = editor.drawflow.drawflow.Home.data[conditionElement].pos_x;
                    editor.drawflow.drawflow.Home.data[rightOption].pos_y = editor.drawflow.drawflow.Home.data[conditionElement].pos_y + 500;
                    document.getElementById("node-" + rightOption).style.top = (editor.drawflow.drawflow.Home.data[conditionElement].pos_y + 500) + "px";
                    document.getElementById("node-" + rightOption).style.left = (editor.drawflow.drawflow.Home.data[conditionElement].pos_x) + "px";
                    editor.updateConnectionNodes("node-" + rightOption);
                    alreadyPositioned.push(stateName[1]);
                }
            }

            // counter++;
        }

        for (let [transitionKey, transition] of Object.entries(combinedTransitionsData)) {
            let sourceElement = mapNodeStateElement[transition['source']];
            let targetElement = mapNodeStateElement[transition['target']];
            let transitionElement = mapNodeTransitionElement[transitionKey];

            // link source to target state - if they are not linked by condition
            if (mapNodeConnectedThruConditions[transition['source']] === undefined) {
                console.log('transition linking source', transition['source'], 'placed');
                console.log('happy', transition['happy'])
                editor.addConnection(sourceElement, targetElement, 'output_1', 'input_1');
            } else {
                if (mapNodeConnectedThruConditions[transition['source']]['states'][transition['target']] === undefined) {
                    console.log('transition linking target', transition['target'], 'placed');
                    editor.addConnection(sourceElement, targetElement, 'output_1', 'input_1');
                } else {
                    if (mapNodeConnectedThruConditions[transition['source']]['transitionKey'].indexOf(transitionKey) === -1) {
                        console.log('transition linking target', transition['target'], 'placed', sourceElement, transitionElement);
                        editor.addConnection(sourceElement, targetElement, 'output_1', 'input_1');
                    }
                }
            }
            if (alreadyPositioned.indexOf(transition['target']) === -1) {
                editor.drawflow.drawflow.Home.data[targetElement].pos_x = editor.drawflow.drawflow.Home.data[sourceElement].pos_x;
                editor.drawflow.drawflow.Home.data[targetElement].pos_y = editor.drawflow.drawflow.Home.data[sourceElement].pos_y + 500;
                document.getElementById("node-" + targetElement).style.top = (editor.drawflow.drawflow.Home.data[sourceElement].pos_y + 500) + "px";
                document.getElementById("node-" + targetElement).style.left = (editor.drawflow.drawflow.Home.data[sourceElement].pos_x) + "px";
                editor.updateConnectionNodes("node-" + targetElement);
            }
        }

        // repositioning nodes that overlap
        do {
            mapNodePositions = [];
            for (let [nodeKey, node] of Object.entries(document.querySelectorAll(".drawflow-node "))) {
                if (mapNodePositions[node.style.left + '_' + node.style.top] === undefined) {
                    mapNodePositions[node.style.left + '_' + node.style.top] = [];
                }
                mapNodePositions[node.style.left + '_' + node.style.top].push(node.id);
            }

            let filteredNodes = Object.values(mapNodePositions).filter(ob => ob.length > 1)
            for (let i = 0; i < filteredNodes.length; i++) {
                for (let j = 1; j < filteredNodes[i].length; j++) {
                    let node = filteredNodes[i][j];
                    let nodeElement = node.split('-')[1];
                    editor.drawflow.drawflow.Home.data[nodeElement].pos_x = editor.drawflow.drawflow.Home.data[nodeElement].pos_x + 250;
                    document.getElementById(node).style.left = (editor.drawflow.drawflow.Home.data[nodeElement].pos_x + 250) + "px";
                    editor.updateConnectionNodes(node);
                }
            }
        } while (Object.values(mapNodePositions).filter(ob => ob.length > 1).length > 0);

        let rightmostNode = 0;
        for (let [nodeKey, node] of Object.entries(document.querySelectorAll(".drawflow-node "))) {
            let leftPosition = +node.style.left.replaceAll('px', '');
            if (leftPosition > rightmostNode) {
                rightmostNode = leftPosition;
            }
        }

        // add events to canvas
        let eventCounter = 0;
        for (let [key, event] of Object.entries(combinedEventsData)) {
            editor.addNode('event', 1, 1, (rightmostNode + 300), (10 + (500 * eventCounter)), '', event, htmlEvent);
            eventCounter++;
        }

        // linking transitions and events
        for (let [transitionKey, transition] of Object.entries(combinedTransitionsData)) {
            console.log(transition)
            let transitionElement = mapNodeTransitionElement[transitionKey];
            let eventElement = combinedEventsData[transition.event];
            // editor.addConnection(transitionElement, eventElement, 'output_1', 'input_1');
        }

        // let label1 = document.querySelector(".connection.node_in_node-2.node_out_node-1.output_1.input_1");

        // addLabelText(label1, "Something");

        function addLabelText(bgPath, labelText) {
            const newid = [bgPath.classList].join().replace(/\s/g, '');
            bgPath.childNodes[0].id = newid;
            let textElem = document.createElementNS(bgPath.namespaceURI, "text");
            let textElemPath = document.createElementNS(bgPath.namespaceURI, "textPath");
            textElemPath.setAttribute("href", `#${newid}`);
            textElemPath.setAttribute("text-anchor", "middle");
            textElemPath.setAttribute("startOffset", "50%");
            textElemPath.classList.add("label-text");
            textElemPath.textContent = labelText;
            textElem.appendChild(textElemPath);
            bgPath.appendChild(textElem);
        }

        processing = false;
    }

    function exportGraph() {
        var exportdata = editor.export();

        let data = exportdata.drawflow.Home.data;
        for (const [key, value] of Object.entries(data)) {
            // // console.log(`${key}`, value);
        }

        document.getElementById('export').value = JSON.stringify(exportdata, null, 4);

        // let baseXml = '<?xml version="1.0"?><statemachine xmlns="spryker:oms-01" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="spryker:oms-01 http://static.spryker.com/oms-01.xsd"></statemachine';
        // let xml = new DOMParser().parseFromString(baseXml, "application/xml");

        let xml = document.implementation.createDocument("", "", null);
        let header = xml.createElementNS("spryker:oms-01", "statemachine");
        header.setAttribute('xmlns:xsi', 'http://www.w3.org/2001/XMLSchema-instance');
        header.setAttribute('xsi:schemaLocation', 'spryker:oms-01 http://static.spryker.com/oms-01.xsd');


        let process = xml.createElement("process");
        process.setAttribute('name', document.getElementsByName('processName')[0].value);
        process.setAttribute('main', 'true');

        let states = xml.createElement("states");
        let transitions = xml.createElement("transitions");
        let events = xml.createElement("events");

        let combinedEvents = [];
        let combinedStates = [];
        let combinedTransitions = [];

        for (const [key, value] of Object.entries(data)) {
            if (value.name === 'state') {
                combinedStates.push(value);

                let newState = xml.createElement("state");
                newState.setAttribute('name', value.data.name ?? '');
                newState.setAttribute('display', value.data.display ?? '');

                if (value.data.reserved === 'true') {
                    newState.setAttribute('reserved', true);
                }

                if (value.data.flag !== undefined && value.data.flag !== "") {
                    let flag = xml.createElement('flag');
                    let flagText = xml.createTextNode(value.data.flag);

                    flag.appendChild(flagText);
                    newState.appendChild(flag);
                }


                states.appendChild(newState);
            }
            if (value.name === 'transition') {
                combinedTransitions.push(value);

                let newTransition = xml.createElement("transition");

                if (value.data.happy === 'true') {
                    newTransition.setAttribute('happy', true);
                }

                if (value.data.condition !== undefined && value.data.condition !== "") {
                    newTransition.setAttribute('condition', value.data.condition);
                }

                let source = xml.createElement('source')
                let sourceText = xml.createTextNode(value.data.source ?? '');
                source.appendChild(sourceText);
                newTransition.appendChild(source);

                let target = xml.createElement('target')
                let targetText = xml.createTextNode(value.data.target ?? '');
                target.appendChild(targetText);
                newTransition.appendChild(target);

                let event = xml.createElement('event')
                let eventText = xml.createTextNode(value.data.event ?? '');
                event.appendChild(eventText);
                newTransition.appendChild(event);

                transitions.appendChild(newTransition);
            }
            if (value.name === 'event') {
                combinedEvents.push(value);

                let newEvent = xml.createElement("event");
                newEvent.setAttribute('name', value.data.name ?? '');

                if (value.data.manual === 'true') {
                    newEvent.setAttribute('manual', true);
                }

                if (value.data.command !== undefined && value.data.command !== "") {
                    newEvent.setAttribute('command', value.data.command);
                }

                if (value.data.timeout !== undefined && value.data.timeout !== "") {
                    newEvent.setAttribute('timeout', value.data.timeout);
                }

                if (value.data.timeoutProcessor !== undefined && value.data.timeoutProcessor !== "") {
                    newEvent.setAttribute('timeoutProcessor', value.data.timeoutProcessor);
                }

                if (value.data.onEnter === 'true') {
                    newEvent.setAttribute('onEnter', true);
                }

                events.appendChild(newEvent);
            }
        }

        process.appendChild(states);
        process.appendChild(transitions);
        process.appendChild(events);

        xml.appendChild(header)
        xml.documentElement.appendChild(process);

        document.getElementById('exportXml').value = new XMLSerializer().serializeToString(xml);
    }

    // MicroModal.init({
    //     onShow: modal => console.info(`${modal.id} is shown`), // [1]
    //     onClose: modal => console.info(`${modal.id} is hidden`), // [2]
    //     // openTrigger: 'data-custom-open', // [3]
    //     // closeTrigger: 'data-custom-close', // [4]
    //     openClass: 'is-open', // [5]
    //     disableScroll: true, // [6]
    //     disableFocus: false, // [7]
    //     awaitOpenAnimation: false, // [8]
    //     awaitCloseAnimation: false, // [9]
    //     debugMode: true // [10]
    // });
    MicroModal.init({
        onShow: modal => console.info(`${modal.id} is shown`),
        // onClose: modal => console.info(`${modal.id} is hidden`),
        debugMode: true
    });

    let modalStateConfig = {
        onShow: modalStateShowHandler,
        onClose: modalStateCloseHandler,
        debugMode: true
    };

    function modalStateShowHandler(modal, param1) {
        document.getElementById('state-name').value = '';
        document.getElementById('state-reserved').value = '';
        document.getElementById('state-flag').value = '';
        document.getElementById('state-display').value = '';
    }

    function modalStateCloseHandler(modal, param1) {
        document.getElementById('state-name').value = '';
        document.getElementById('state-reserved').value = '';
        document.getElementById('state-flag').value = '';
        document.getElementById('state-display').value = '';
        document.getElementById('state-nodeId').value = '';
    }

    function createOrUpdateStateData() {
        console.log('createOrUpdateStateData')
        let id = document.getElementById('state-nodeId').value;
        let node = editor.getNodeFromId(id);
        console.log(node.data, node.data.name, combinedStatesData[node.data.name]);

        let originalNodeData = combinedStatesData[node.data.name];
        if (node.data.name !== document.getElementById('state-name').value) {
            delete combinedStatesData[node.data.name];
        }

        console.log(originalNodeData);

        let data = {
            ...originalNodeData,
            "name": document.getElementById('state-name').value,
            "color": '#ebf2eb',
            "flag": document.getElementById('state-flag').value,
            "reserved": (document.getElementById('state-reserved').value !== '') ? document.getElementById('state-reserved').value : 'false',
            "display": document.getElementById('state-display').value,
            "nodeId": id,
            "childrenCount": 0,
            "childrenNames": [],
            "statesCount": 0,
            "stateNames": [],
        };

        combinedStatesData[document.getElementById('state-name').value] = data;
        editor.updateNodeDataFromId(id, data);

        let locStateHtml = htmlState.replaceAll('==content==', data.name);
        console.log(locStateHtml)
        editor.drawflow.drawflow.Home.data[id].html = locStateHtml;
        document.querySelector('#node-' + id + ' .drawflow_content_node').innerHTML = locStateHtml;

        MicroModal.close('modal-state', modalStateConfig);
    }


    // EVENTS
    // Events!
    editor.on('nodeCreated', function (id) {
        console.log("Node created " + id);
        if (processing === true) {
            return;
        }

        const node = editor.getNodeFromId(id);
        if (node.name === 'state') {

            MicroModal.show('modal-state', modalStateConfig);
            console.log('nodeCreated', node.data)

            let data = {
                "name": '',
                "color": '#ebf2eb',
                "flag": '',
                "reserved": 'false',
                "display": '',
                "nodeId": id,
                "childrenCount": 0,
                "childrenNames": [],
                "statesCount": 0,
                "stateNames": [],
                'posX': node.pos_x,
                'posY': node.pos_y,
            };

            console.log(data);

            combinedStatesData[''] = data;
            editor.updateNodeDataFromId(id, data);

            document.getElementById('state-nodeId').value = id;
            const check = node.html.includes('select');
            if (check) {
                const reservedOptions = document.querySelectorAll(`#node-${id} select[name="df-reserved"] option`);
                reservedOptions.forEach(e => {
                    if (e.value === node.data.reserved) {
                        e.selected = true;
                    }
                });
            }
        }
        if (node.name === 'condition') {
            MicroModal.show('modal-condition');
        }
        if (node.name === 'transition') {
            const check = node.html.includes('select');
            if (check) {
                const happyOptions = document.querySelectorAll(`#node-${id} select[name="df-happy"] option`);
                happyOptions.forEach(e => {
                    if (e.value === node.data.happy) {
                        e.selected = true;
                    }
                });
            }
        }
        if (node.name === 'event') {
            const check = node.html.includes('select');
            console.log(check)
            if (check) {
                const onEnterOptions = document.querySelectorAll(`#node-${id} select[name="df-onEnter"] option`);
                onEnterOptions.forEach(e => {
                    if (e.value === node.data.onEnter) {
                        e.selected = true;
                    }
                });
                const manualrOptions = document.querySelectorAll(`#node-${id} select[name="df-manual"] option`);
                manualrOptions.forEach(e => {
                    if (e.value === node.data.manual) {
                        e.selected = true;
                    }
                });
            }
        }
    })

    editor.on('nodeRemoved', function (id) {
        console.log("Node removed " + id);
    })

    editor.on('nodeSelected', function (id) {
        console.log("Node selected " + id);
    })

    editor.on('nodeDataChanged', function (id) {
        console.log("Node changed " + id);
        const node = editor.getNodeFromId(id);
        console.log(node.data);
        console.log(mapNodeDependencies[id])
        if (mapNodeDependencies[id] !== undefined) {
            for (let i = 0; i < mapNodeDependencies[id]['source'].length; i++) {
                const dependantNode = editor.getNodeFromId(mapNodeDependencies[id]['source'][i]);
                if (dependantNode.name === 'transition') {
                    if (node.data.name !== undefined) {
                        dependantNode.data.source = node.data.name;
                        editor.updateNodeDataFromId(mapNodeDependencies[id]['source'][i], dependantNode.data);
                    }
                }
            }
            for (let i = 0; i < mapNodeDependencies[id]['target'].length; i++) {
                const dependantNode = editor.getNodeFromId(mapNodeDependencies[id]['target'][i]);
                if (dependantNode.name === 'transition') {
                    if (node.data.name !== undefined) {
                        dependantNode.data.target = node.data.name;
                        editor.updateNodeDataFromId(mapNodeDependencies[id]['target'][i], dependantNode.data);
                    }
                }
            }
            for (let i = 0; i < mapNodeDependencies[id]['event'].length; i++) {
                const dependantNode = editor.getNodeFromId(mapNodeDependencies[id]['event'][i]);
                if (dependantNode.name === 'transition') {
                    if (node.data.name !== undefined) {
                        dependantNode.data.event = node.data.name;
                        editor.updateNodeDataFromId(mapNodeDependencies[id]['event'][i], dependantNode.data);
                    }
                }
            }
        }
    })

    editor.on('moduleCreated', function (name) {
        console.log("Module Created " + name);
    })

    editor.on('moduleChanged', function (name) {
        console.log("Module Changed " + name);
    })

    editor.on('connectionCreated', function (connection) {
        console.log('Connection created');
        console.log(connection);

        const inputNodeInfo = editor.getNodeFromId(connection.input_id);
        const outputNodeInfo = editor.getNodeFromId(connection.output_id);

        if (mapNodeDependencies[connection.output_id] === undefined) {
            mapNodeDependencies[connection.output_id] = [];
            mapNodeDependencies[connection.output_id]['source'] = [];
            mapNodeDependencies[connection.output_id]['target'] = [];
            mapNodeDependencies[connection.output_id]['event'] = [];
        }

        if (mapNodeDependencies[connection.input_id] === undefined) {
            mapNodeDependencies[connection.input_id] = [];
            mapNodeDependencies[connection.input_id]['source'] = [];
            mapNodeDependencies[connection.input_id]['target'] = [];
            mapNodeDependencies[connection.input_id]['event'] = [];
        }

        if (outputNodeInfo.name === 'state') {
            if (inputNodeInfo.name === 'state') {
                MicroModal.show('modal-transition');
            }
            if (inputNodeInfo.name === 'transition') {
                inputNodeInfo.data.source = outputNodeInfo.data.name ?? '';
                editor.updateNodeDataFromId(connection.input_id, inputNodeInfo.data);
                mapNodeDependencies[connection.output_id]['source'].push(connection.input_id);
            }
        }

        if (outputNodeInfo.name === 'transition') {
            if (inputNodeInfo.name === 'state') {
                outputNodeInfo.data.target = inputNodeInfo.data.name ?? '';
                editor.updateNodeDataFromId(connection.output_id, outputNodeInfo.data);
                mapNodeDependencies[connection.input_id]['target'].push(connection.output_id);
            }
            if (inputNodeInfo.name === 'event') {
                outputNodeInfo.data.event = inputNodeInfo.data.name ?? '';
                editor.updateNodeDataFromId(connection.output_id, outputNodeInfo.data);
                mapNodeDependencies[connection.input_id]['event'].push(connection.output_id);
            }
        }

        if (outputNodeInfo.name === 'condition') {
            // a condition can only have 2 connections
            // TODO: implement some alert/notification
            if (outputNodeInfo.outputs[connection.output_class].connections.length > 2) {
                const removeConnectionInfo = outputNodeInfo.outputs[connection.output_class].connections.pop();
                editor.removeSingleConnection(connection.output_id, removeConnectionInfo.node, connection.output_class, removeConnectionInfo.output);
                return;
            }

            if (inputNodeInfo.name === 'transition') {
                const parentFromCondition = outputNodeInfo.inputs.input_1.connections[0].node
                const parentFromConditionNodeInfo = editor.getNodeFromId(parentFromCondition);

                inputNodeInfo.data.source = parentFromConditionNodeInfo.data.name ?? '';
                editor.updateNodeDataFromId(connection.input_id, inputNodeInfo.data);
                mapNodeDependencies[parentFromCondition]['source'].push(connection.input_id);
            }
        }

        if (inputNodeInfo.name === 'transition' && outputNodeInfo.name === 'state') {

        }
        if (inputNodeInfo.name === 'transition' && outputNodeInfo.name === 'event') {
            editor.updateNodeDataFromId(connection.output_id, {event: outputNodeInfo.data.name});
        }

        // let sourceNode = editor.getNodeFromId(connection.output_id);
        // let targetNode = editor.getNodeFromId(connection.input_id);
        // if (sourceNode.name === 'state' && targetNode.name === 'transition') {
        //     editor.updateNodeDataFromId(connection.input_id, { source: sourceNode.data.name });
        // }
        // if (sourceNode.name === 'transition' && targetNode.name === 'event') {
        //     editor.updateNodeDataFromId(connection.output_id, { event: targetNode.data.name });
        // }

        // console.log(sourceNode, targetNode);

    })

    editor.on('connectionRemoved', function (connection) {
        console.log('Connection removed');
        console.log(connection);

        const inputNodeInfo = editor.getNodeFromId(connection.input_id);
        const outputNodeInfo = editor.getNodeFromId(connection.output_id);
        if (mapNodeDependencies[connection.output_id] !== undefined) {
            let toRemove = mapNodeDependencies[connection.output_id].indexOf(connection.input_id);
            if (toRemove !== -1) {
                mapNodeDependencies[connection.output_id].splice(toRemove, 1);
            }
        }
        console.log(mapNodeDependencies)
    })

    editor.on('mouseMove', function (position) {
        // console.log('Position mouse x:' + position.x + ' y:' + position.y);
    })

    editor.on('nodeMoved', function (id) {
        console.log("Node moved " + id);
        let nodeData = editor.getNodeFromId(id);
        console.log(nodeData);
        if (combinedStatesData[nodeData.data.name] === undefined) {
            combinedStatesData[nodeData.data.name] = [];
        }

        if (nodeData.name === 'state') {
            combinedStatesData[nodeData.data.name]['posX'] = nodeData.pos_x;
            combinedStatesData[nodeData.data.name]['posY'] = nodeData.pos_y;
        }
        console.log(nodeData.data);
    })

    editor.on('zoom', function (zoom) {
        console.log('Zoom level ' + zoom);
    })

    editor.on('translate', function (position) {
        // console.log('Translate x:' + position.x + ' y:' + position.y);
    })

    editor.on('addReroute', function (id) {
        console.log("Reroute added " + id);
    })

    editor.on('removeReroute', function (id) {
        console.log("Reroute removed " + id);
    })

    /* DRAG EVENT */

    /* Mouse and Touch Actions */

    var elements = document.getElementsByClassName('drag-drawflow');
    for (var i = 0; i < elements.length; i++) {
        elements[i].addEventListener('touchend', drop, false);
        elements[i].addEventListener('touchmove', positionMobile, false);
        elements[i].addEventListener('touchstart', drag, false);
    }

    var mobile_item_selec = '';
    var mobile_last_move = null;

    function positionMobile(ev) {
        mobile_last_move = ev;
    }

    function allowDrop(ev) {
        ev.preventDefault();
    }

    function drag(ev) {
        if (ev.type === "touchstart") {
            mobile_item_selec = ev.target.closest(".drag-drawflow").getAttribute('data-node');
        } else {
            ev.dataTransfer.setData("node", ev.target.getAttribute('data-node'));
        }
    }

    function drop(ev) {
        if (ev.type === "touchend") {
            var parentdrawflow = document.elementFromPoint(mobile_last_move.touches[0].clientX, mobile_last_move.touches[0].clientY).closest("#drawflow");
            if (parentdrawflow != null) {
                addNodeToDrawFlow(mobile_item_selec, mobile_last_move.touches[0].clientX, mobile_last_move.touches[0].clientY);
            }
            mobile_item_selec = '';
        } else {
            ev.preventDefault();
            var data = ev.dataTransfer.getData("node");
            addNodeToDrawFlow(data, ev.clientX, ev.clientY);
        }

    }

    function addNodeToDrawFlow(name, pos_x, pos_y) {
        if (editor.editor_mode === 'fixed') {
            return false;
        }
        pos_x = pos_x * (editor.precanvas.clientWidth / (editor.precanvas.clientWidth * editor.zoom)) - (editor.precanvas.getBoundingClientRect().x * (editor.precanvas.clientWidth / (editor.precanvas.clientWidth * editor.zoom)));
        pos_y = pos_y * (editor.precanvas.clientHeight / (editor.precanvas.clientHeight * editor.zoom)) - (editor.precanvas.getBoundingClientRect().y * (editor.precanvas.clientHeight / (editor.precanvas.clientHeight * editor.zoom)));


        switch (name) {
            case 'state':
                editor.addNode('state', 1, 1, pos_x, pos_y, '', {}, htmlState);
                break;
            case 'condition':
                editor.addNode('condition', 1, 2, pos_x, pos_y, 'romb state', {}, htmlCondition);
                break;
            case 'transition':
                editor.addNode('transition', 1, 1, pos_x, pos_y, '', {}, htmlTransition);
                break;
            case 'event':
                editor.addNode('event', 1, 1, pos_x, pos_y, '', {}, htmlEvent);
                break;


            default:
        }
    }

    const upload = async (event) => {

        // Convert the FileList into an array and iterate
        let files = Array.from(event.target.files).map(file => {

            // Define a new file reader
            let reader = new FileReader();

            // Create a new promise
            return new Promise(resolve => {

                // Resolve the promise after reading file
                reader.onload = () => resolve(reader.result);

                // Read the file as a text
                reader.readAsText(file);

            });

        });

        // At this point you'll have an array of results
        let res = await Promise.all(files);

        for (let index = 0; index < res.length; index++) {
            const element = res[index];
            let textarea = document.createElement('textarea');
            textarea.setAttribute('class', 'xml');
            textarea.innerText = element;
            document.getElementById('textareas').appendChild(textarea);
        }
    }


    // changes on connector lines design
    // editor.curvature = 0;
    // editor.reroute_curvature_start_end = 0;
    // editor.reroute_curvature = 0;

    // editor.createCurvature = function(start_pos_x, start_pos_y, end_pos_x, end_pos_y, curvature_value) {
    //   var center_x = ((end_pos_x - start_pos_x)/2)+start_pos_x;
    //   return ' M ' + start_pos_x + ' ' + start_pos_y + ' L '+ center_x +' ' +  start_pos_y  + ' L ' + center_x + ' ' +  end_pos_y  + ' L ' + end_pos_x + ' ' + end_pos_y;
    // }

    // editor.createCurvature = function (start_pos_x, start_pos_y, end_pos_x, end_pos_y, curvature_value) {
    //     if (end_pos_y > start_pos_y) {

    //         var center_y = ((end_pos_y - start_pos_y) / 2) + start_pos_y;
    //         return ' M ' + start_pos_x + ' ' + start_pos_y + ' L ' + start_pos_x + ' ' + center_y + ' L ' + end_pos_x + ' ' + center_y + ' L ' + end_pos_x + ' ' + end_pos_y;

    //     } else {

    //         // New curvature
    //         return ' M ...';
    //     }
    // }

    editor.on('clickEnd', function (e) {
        if (e.detail === 2 && e.target.classList[0] === "main-path") {
            console.log(editor.connection_selected);
        }
    });

    // detect click on connector line and get source and target nodes
    var connectionSourceNodeId = -1;
    var connectionTargetNodeId = -1;
    editor.on('click', function (e) {
        if (e.detail === 2 && e.target.classList[0] === "main-path") {
            console.log(editor.connection_selected);
            console.log(e.path[1]);

            let nodeArray = e.path[1].getAttribute('class').split(' ');

            for (let index = 0; index < nodeArray.length; index++) {
                const element = nodeArray[index];

                if (element.indexOf('node_in_node-') !== -1) {
                    connectionTargetNodeId = element.split('-')[1];
                }

                if (element.indexOf('node_out_node-') !== -1) {
                    connectionSourceNodeId = element.split('-')[1];
                }
            }

            console.log(connectionSourceNodeId, connectionTargetNodeId);
            MicroModal.show('modal-transition');

        }
    });


    function showpopup(e) {
        let nodeId = e.path[2].id.split('-')[1];
        let nodeData = editor.getNodeFromId(nodeId);

        if (nodeData.name === 'state') {
            console.log(nodeData.data);
            MicroModal.show('modal-state', modalStateConfig);
            document.getElementById('state-name').value = nodeData.data.name;
            document.getElementById('state-reserved').value = nodeData.data.reserved;
            document.getElementById('state-flag').value = nodeData.data.flag;
            document.getElementById('state-display').value = nodeData.data.display;
            document.getElementById('state-nodeId').value = nodeData.data.nodeId;
        }
        if (nodeData.name === 'condition') {
            MicroModal.show('modal-condition');
        }
    }

    function closemodal(e) {
        e.target.closest(".drawflow-node").style.zIndex = "2";
        e.target.parentElement.parentElement.style.display = "none";
        //document.getElementById("modalfix").style.display = "none";
        editor.precanvas.style.transform = transform;
        editor.precanvas.style.left = '0px';
        editor.precanvas.style.top = '0px';
        editor.editor_mode = "edit";
    }

</script>
</body>

</html>
